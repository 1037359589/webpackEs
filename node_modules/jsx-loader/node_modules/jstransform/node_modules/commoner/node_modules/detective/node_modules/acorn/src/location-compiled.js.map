{"version":3,"sources":["location.js"],"names":[],"mappings":"AAAA,SAAQ,MAAM,QAAO,SAAS,CAAA;AAC9B,SAAQ,UAAU,QAAO,cAAc,CAAA;AACvC,SAAQ,SAAS,QAAO,MAAM;;;;;AAAA,AAK9B,OAAO,MAAM,QAAQ,CAAC;AACpB,aAAW,CAAC,IAAI,EAAE,GAAG,EAAE;AACrB,QAAI,CAAC,IAAI,GAAG,IAAI,CAAA;AAChB,QAAI,CAAC,MAAM,GAAG,GAAG,CAAA;GAClB;;AAED,QAAM,CAAC,CAAC,EAAE;AACR,WAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;GAChD;CACF;;AAED,OAAO,MAAM,cAAc,CAAC;AAC1B,aAAW,CAAC,CAAC,EAAE,KAAK,EAAE,GAAG,EAAE;AACzB,QAAI,CAAC,KAAK,GAAG,KAAK,CAAA;AAClB,QAAI,CAAC,GAAG,GAAG,GAAG,CAAA;AACd,QAAI,CAAC,CAAC,UAAU,KAAK,IAAI,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,UAAU,CAAA;GACtD;CACF;;;;;;;;AAAA,AAQD,OAAO,SAAS,WAAW,CAAC,KAAK,EAAE,MAAM,EAAE;AACzC,OAAK,IAAI,IAAI,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,IAAI;AAC5B,cAAU,CAAC,SAAS,GAAG,GAAG,CAAA;AAC1B,QAAI,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AAClC,QAAI,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,MAAM,EAAE;AACjC,QAAE,IAAI,CAAA;AACN,SAAG,GAAG,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAA;KACpC,MAAM;AACL,aAAO,IAAI,QAAQ,CAAC,IAAI,EAAE,MAAM,GAAG,GAAG,CAAC,CAAA;KACxC;GACF;CACF;;AAED,MAAM,EAAE,GAAG,MAAM,CAAC,SAAS;;;;;;;;AAAA,AAQ3B,EAAE,CAAC,KAAK,GAAG,UAAS,GAAG,EAAE,OAAO,EAAE;AAChC,MAAI,GAAG,GAAG,WAAW,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAA;AACtC,SAAO,IAAI,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,MAAM,GAAG,GAAG,CAAA;AACnD,MAAI,GAAG,GAAG,IAAI,WAAW,CAAC,OAAO,CAAC,CAAA;AAClC,KAAG,CAAC,GAAG,GAAG,GAAG,CAAC,AAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,AAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAA;AACrD,QAAM,GAAG,CAAA;CACV,CAAA;;AAED,EAAE,CAAC,WAAW,GAAG,YAAW;AAC1B,SAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,CAAA;CAC7D,CAAA;;AAED,EAAE,CAAC,YAAY,GAAG,YAAW;AAC3B,SAAO,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,KAAK,CAAA;CACzE,CAAA","file":"location-compiled.js","sourcesContent":["import {Parser} from \"./state\"\nimport {lineBreakG} from \"./whitespace\"\nimport {deprecate} from \"util\"\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nexport class Position {\n  constructor(line, col) {\n    this.line = line\n    this.column = col\n  }\n\n  offset(n) {\n    return new Position(this.line, this.column + n)\n  }\n}\n\nexport class SourceLocation {\n  constructor(p, start, end) {\n    this.start = start\n    this.end = end\n    if (p.sourceFile !== null) this.source = p.sourceFile\n  }\n}\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nexport function getLineInfo(input, offset) {\n  for (let line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur\n    let match = lineBreakG.exec(input)\n    if (match && match.index < offset) {\n      ++line\n      cur = match.index + match[0].length\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\nconst pp = Parser.prototype\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp.raise = function(pos, message) {\n  let loc = getLineInfo(this.input, pos)\n  message += \" (\" + loc.line + \":\" + loc.column + \")\"\n  let err = new SyntaxError(message)\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos\n  throw err\n}\n\npp.curPosition = function() {\n  return new Position(this.curLine, this.pos - this.lineStart)\n}\n\npp.markPosition = function() {\n  return this.options.locations ? [this.start, this.startLoc] : this.start\n}\n"]}