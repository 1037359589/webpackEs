{"version":3,"sources":["options.js"],"names":[],"mappings":"AAAA,SAAQ,GAAG,EAAE,OAAO,QAAO,QAAQ,CAAA;AACnC,SAAQ,cAAc,QAAO,YAAY;;;;;AAAA,AAKzC,OAAO,MAAM,cAAc,GAAG;;;;;AAK5B,aAAW,EAAE,CAAC;;AAEd,YAAU,EAAE,QAAQ;;;;;;AAMpB,qBAAmB,EAAE,IAAI;;;AAGzB,iBAAe,EAAE,IAAI;;;;;AAKrB,eAAa,EAAE,IAAI;;;AAGnB,4BAA0B,EAAE,KAAK;;;AAGjC,6BAA2B,EAAE,KAAK;;;AAGlC,eAAa,EAAE,KAAK;;;;;AAKpB,WAAS,EAAE,KAAK;;;;;;AAMhB,SAAO,EAAE,IAAI;;;;;;;;;;;AAWb,WAAS,EAAE,IAAI;;;;;;;;;AASf,QAAM,EAAE,KAAK;;;;;;AAMb,SAAO,EAAE,IAAI;;;AAGb,YAAU,EAAE,IAAI;;;AAGhB,kBAAgB,EAAE,IAAI;;;AAGtB,gBAAc,EAAE,KAAK;AACrB,SAAO,EAAE,EAAE;CACZ,CAAA;;;;AAAA,AAID,OAAO,SAAS,UAAU,CAAC,IAAI,EAAE;AAC/B,MAAI,OAAO,GAAG,EAAE,CAAA;AAChB,OAAK,IAAI,GAAG,IAAI,cAAc,EAC5B,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,CAAA;;AAEzE,MAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;AAC5B,QAAI,MAAM,GAAG,OAAO,CAAC,OAAO,CAAA;AAC5B,WAAO,CAAC,OAAO,GAAG,AAAC,KAAK,IAAK,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;GAChD;AACD,MAAI,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,EAC5B,OAAO,CAAC,SAAS,GAAG,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,SAAS,CAAC,CAAA;;AAE7D,SAAO,OAAO,CAAA;CACf;;AAED,SAAS,WAAW,CAAC,OAAO,EAAE,KAAK,EAAE;AACnC,SAAO,UAAU,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,EAAE;AAC1D,QAAI,OAAO,GAAG;AACZ,UAAI,EAAE,KAAK,GAAG,OAAO,GAAG,MAAM;AAC9B,WAAK,EAAE,IAAI;AACX,WAAK,EAAE,KAAK;AACZ,SAAG,EAAE,GAAG;KACT,CAAA;AACD,QAAI,OAAO,CAAC,SAAS,EACnB,OAAO,CAAC,GAAG,GAAG,IAAI,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAA;AAC1D,QAAI,OAAO,CAAC,MAAM,EAChB,OAAO,CAAC,KAAK,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAA;AAC9B,SAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;GACpB,CAAA;CACF","file":"options-compiled.js","sourcesContent":["import {has, isArray} from \"./util\"\nimport {SourceLocation} from \"./location\"\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nexport const defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, or 5, or 6. This influences support for strict\n  // mode, the set of reserved words, support for getters and\n  // setters and other features.\n  ecmaVersion: 5,\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are not enforced. Disable\n  // `allowReserved` to enforce them. When this option has the\n  // value \"never\", reserved words and keywords can also not be\n  // used as property names.\n  allowReserved: true,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokenize() returns. Note that you are not\n  // allowed to call the parser from the callback—that will\n  // corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}\n\n// Interpret and default an options object\n\nexport function getOptions(opts) {\n  let options = {}\n  for (let opt in defaultOptions)\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n\n  if (isArray(options.onToken)) {\n    let tokens = options.onToken\n    options.onToken = (token) => tokens.push(token)\n  }\n  if (isArray(options.onComment))\n    options.onComment = pushComment(options, options.onComment)\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    let comment = {\n      type: block ? 'Block' : 'Line',\n      value: text,\n      start: start,\n      end: end\n    }\n    if (options.locations)\n      comment.loc = new SourceLocation(this, startLoc, endLoc)\n    if (options.ranges)\n      comment.range = [start, end]\n    array.push(comment)\n  }\n}\n\n"]}