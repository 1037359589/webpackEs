{"version":3,"sources":["tokencontext.js"],"names":[],"mappings":"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","file":"tokencontext-compiled.js","sourcesContent":["// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nimport {Parser} from \"./state\"\nimport {types as tt} from \"./tokentype\"\nimport {lineBreak} from \"./whitespace\"\n\nexport class TokContext {\n  constructor(token, isExpr, preserveSpace, override) {\n    this.token = token\n    this.isExpr = isExpr\n    this.preserveSpace = preserveSpace\n    this.override = override\n  }\n}\n\nexport const types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, p => p.readTmplToken()),\n  f_expr: new TokContext(\"function\", true)\n}\n\nconst pp = Parser.prototype\n\npp.initialContext = function() {\n  return [types.b_stat]\n}\n\npp.braceIsBlock = function(prevType) {\n  let parent\n  if (prevType === tt.colon && (parent = this.curContext()).token == \"{\")\n    return !parent.isExpr\n  if (prevType === tt._return)\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof)\n    return true\n  if (prevType == tt.braceL)\n    return this.curContext() === types.b_stat\n  return !this.exprAllowed\n}\n\npp.updateContext = function(prevType) {\n  let update, type = this.type\n  if (type.keyword && prevType == tt.dot)\n    this.exprAllowed = false\n  else if (update = type.updateContext)\n    update.call(this, prevType)\n  else\n    this.exprAllowed = type.beforeExpr\n}\n\n// Token-specific context update code\n\ntt.parenR.updateContext = tt.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true\n    return\n  }\n  let out = this.context.pop()\n  if (out === types.b_stat && this.curContext() === types.f_expr) {\n    this.context.pop()\n    this.exprAllowed = false\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true\n  } else {\n    this.exprAllowed = !out.isExpr\n  }\n}\n\ntt.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)\n  this.exprAllowed = true\n}\n\ntt.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl)\n  this.exprAllowed = true\n}\n\ntt.parenL.updateContext = function(prevType) {\n  let statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while\n  this.context.push(statementParens ? types.p_stat : types.p_expr)\n  this.exprAllowed = true\n}\n\ntt.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n}\n\ntt._function.updateContext = function() {\n  if (this.curContext() !== types.b_stat)\n    this.context.push(types.f_expr)\n  this.exprAllowed = false\n}\n\ntt.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    this.context.pop()\n  else\n    this.context.push(types.q_tmpl)\n  this.exprAllowed = false\n}\n"]}