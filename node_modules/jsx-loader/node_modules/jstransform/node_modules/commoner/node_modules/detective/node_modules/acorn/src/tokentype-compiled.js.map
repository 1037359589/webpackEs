{"version":3,"sources":["tokentype.js"],"names":[],"mappings":"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","file":"tokentype-compiled.js","sourcesContent":["// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nexport class TokenType {\n  constructor(label, conf = {}) {\n    this.label = label\n    this.keyword = conf.keyword\n    this.beforeExpr = !!conf.beforeExpr\n    this.startsExpr = !!conf.startsExpr\n    this.isLoop = !!conf.isLoop\n    this.isAssign = !!conf.isAssign\n    this.prefix = !!conf.prefix\n    this.postfix = !!conf.postfix\n    this.binop = conf.binop || null\n    this.updateContext = null\n  }\n}\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nconst beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true}\n\nexport const types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10)\n}\n\n// Map keyword names to token types.\n\nexport const keywords = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options = {}) {\n  options.keyword = name\n  keywords[name] = types[\"_\" + name] = new TokenType(name, options)\n}\n\nkw(\"break\")\nkw(\"case\", beforeExpr)\nkw(\"catch\")\nkw(\"continue\")\nkw(\"debugger\")\nkw(\"default\")\nkw(\"do\", {isLoop: true})\nkw(\"else\", beforeExpr)\nkw(\"finally\")\nkw(\"for\", {isLoop: true})\nkw(\"function\", startsExpr)\nkw(\"if\")\nkw(\"return\", beforeExpr)\nkw(\"switch\")\nkw(\"throw\", beforeExpr)\nkw(\"try\")\nkw(\"var\")\nkw(\"let\")\nkw(\"const\")\nkw(\"while\", {isLoop: true})\nkw(\"with\")\nkw(\"new\", {beforeExpr: true, startsExpr: true})\nkw(\"this\", startsExpr)\nkw(\"super\", startsExpr)\nkw(\"class\")\nkw(\"extends\", beforeExpr)\nkw(\"export\")\nkw(\"import\")\nkw(\"yield\", {beforeExpr: true, startsExpr: true})\nkw(\"null\", startsExpr)\nkw(\"true\", startsExpr)\nkw(\"false\", startsExpr)\nkw(\"in\", {beforeExpr: true, binop: 7})\nkw(\"instanceof\", {beforeExpr: true, binop: 7})\nkw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true})\nkw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true})\nkw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n"]}