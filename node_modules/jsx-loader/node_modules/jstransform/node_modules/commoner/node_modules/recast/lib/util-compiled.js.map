{"version":3,"sources":["util.js"],"names":[],"mappings":"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","file":"util-compiled.js","sourcesContent":["var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar getFieldValue = types.getFieldValue;\nvar n = types.namedTypes;\nvar sourceMap = require(\"source-map\");\nvar SourceMapConsumer = sourceMap.SourceMapConsumer;\nvar SourceMapGenerator = sourceMap.SourceMapGenerator;\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar util = exports;\n\nfunction getUnionOfKeys() {\n  var result = {};\n  var argc = arguments.length;\n  for (var i = 0; i < argc; ++i) {\n    var keys = Object.keys(arguments[i]);\n    var keyCount = keys.length;\n    for (var j = 0; j < keyCount; ++j) {\n      result[keys[j]] = true;\n    }\n  }\n  return result;\n}\nutil.getUnionOfKeys = getUnionOfKeys;\n\nfunction comparePos(pos1, pos2) {\n  return (pos1.line - pos2.line) || (pos1.column - pos2.column);\n}\nutil.comparePos = comparePos;\n\nfunction copyPos(pos) {\n  return {\n    line: pos.line,\n    column: pos.column\n  };\n}\nutil.copyPos = copyPos;\n\nutil.composeSourceMaps = function(formerMap, latterMap) {\n  if (formerMap) {\n    if (!latterMap) {\n      return formerMap;\n    }\n  } else {\n    return latterMap || null;\n  }\n\n  var smcFormer = new SourceMapConsumer(formerMap);\n  var smcLatter = new SourceMapConsumer(latterMap);\n  var smg = new SourceMapGenerator({\n    file: latterMap.file,\n    sourceRoot: latterMap.sourceRoot\n  });\n\n  var sourcesToContents = {};\n\n  smcLatter.eachMapping(function(mapping) {\n    var origPos = smcFormer.originalPositionFor({\n      line: mapping.originalLine,\n      column: mapping.originalColumn\n    });\n\n    var sourceName = origPos.source;\n    if (sourceName === null) {\n      return;\n    }\n\n    smg.addMapping({\n      source: sourceName,\n      original: copyPos(origPos),\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      },\n      name: mapping.name\n    });\n\n    var sourceContent = smcFormer.sourceContentFor(sourceName);\n    if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {\n      sourcesToContents[sourceName] = sourceContent;\n      smg.setSourceContent(sourceName, sourceContent);\n    }\n  });\n\n  return smg.toJSON();\n};\n\nutil.getTrueLoc = function(node, lines) {\n  // It's possible that node is newly-created (not parsed by Esprima),\n  // in which case it probably won't have a .loc property (or an\n  // .original property for that matter). That's fine; we'll just\n  // pretty-print it as usual.\n  if (!node.loc) {\n    return null;\n  }\n\n  var result = {\n    start: node.loc.start,\n    end: node.loc.end\n  };\n\n  function include(node) {\n    expandLoc(result, node.loc);\n  }\n\n  // If the node has any comments, their locations might contribute to\n  // the true start/end positions of the node.\n  if (node.comments) {\n    node.comments.forEach(include);\n  }\n\n  // If the node is an export declaration and its .declaration has any\n  // decorators, their locations might contribute to the true start/end\n  // positions of the export declaration node.\n  if (util.isExportDeclaration(node) &&\n      node.declaration.decorators) {\n    node.declaration.decorators.forEach(include);\n  }\n\n  if (comparePos(result.start, result.end) < 0) {\n    // Trim leading whitespace.\n    result.start = copyPos(result.start);\n    lines.skipSpaces(result.start, false, true);\n\n    if (comparePos(result.start, result.end) < 0) {\n      // Trim trailing whitespace, if the end location is not already the\n      // same as the start location.\n      result.end = copyPos(result.end);\n      lines.skipSpaces(result.end, true, true);\n    }\n  }\n\n  return result;\n};\n\nfunction expandLoc(parentLoc, childLoc) {\n  if (parentLoc && childLoc) {\n    if (comparePos(childLoc.start, parentLoc.start) < 0) {\n      parentLoc.start = childLoc.start;\n    }\n\n    if (comparePos(parentLoc.end, childLoc.end) < 0) {\n      parentLoc.end = childLoc.end;\n    }\n  }\n}\n\nutil.fixFaultyLocations = function(node, lines) {\n  var loc = node.loc;\n  if (loc) {\n    if (loc.start.line < 1) {\n      loc.start.line = 1;\n    }\n\n    if (loc.end.line < 1) {\n      loc.end.line = 1;\n    }\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    fixTemplateLiteral(node, lines);\n\n  } else if (loc && node.decorators) {\n    // Expand the .loc of the node responsible for printing the decorators\n    // (here, the decorated node) so that it includes node.decorators.\n    node.decorators.forEach(function (decorator) {\n      expandLoc(loc, decorator.loc);\n    });\n\n  } else if (node.declaration && util.isExportDeclaration(node)) {\n    // Nullify .loc information for the child declaration so that we never\n    // try to reprint it without also reprinting the export declaration.\n    node.declaration.loc = null;\n\n    // Expand the .loc of the node responsible for printing the decorators\n    // (here, the export declaration) so that it includes node.decorators.\n    var decorators = node.declaration.decorators;\n    if (decorators) {\n      decorators.forEach(function (decorator) {\n        expandLoc(loc, decorator.loc);\n      });\n    }\n\n  } else if ((n.MethodDefinition && n.MethodDefinition.check(node)) ||\n             (n.Property.check(node) && (node.method || node.shorthand))) {\n    // If the node is a MethodDefinition or a .method or .shorthand\n    // Property, then the location information stored in\n    // node.value.loc is very likely untrustworthy (just the {body}\n    // part of a method, or nothing in the case of shorthand\n    // properties), so we null out that information to prevent\n    // accidental reuse of bogus source code during reprinting.\n    node.value.loc = null;\n\n    if (n.FunctionExpression.check(node.value)) {\n      // FunctionExpression method values should be anonymous,\n      // because their .id fields are ignored anyway.\n      node.value.id = null;\n    }\n  }\n};\n\nfunction fixTemplateLiteral(node, lines) {\n  assert.strictEqual(node.type, \"TemplateLiteral\");\n\n  if (node.quasis.length === 0) {\n    // If there are no quasi elements, then there is nothing to fix.\n    return;\n  }\n\n  // First we need to exclude the opening ` from the .loc of the first\n  // quasi element, in case the parser accidentally decided to include it.\n  var afterLeftBackTickPos = copyPos(node.loc.start);\n  assert.strictEqual(lines.charAt(afterLeftBackTickPos), \"`\");\n  assert.ok(lines.nextPos(afterLeftBackTickPos));\n  var firstQuasi = node.quasis[0];\n  if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {\n    firstQuasi.loc.start = afterLeftBackTickPos;\n  }\n\n  // Next we need to exclude the closing ` from the .loc of the last quasi\n  // element, in case the parser accidentally decided to include it.\n  var rightBackTickPos = copyPos(node.loc.end);\n  assert.ok(lines.prevPos(rightBackTickPos));\n  assert.strictEqual(lines.charAt(rightBackTickPos), \"`\");\n  var lastQuasi = node.quasis[node.quasis.length - 1];\n  if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {\n    lastQuasi.loc.end = rightBackTickPos;\n  }\n\n  // Now we need to exclude ${ and } characters from the .loc's of all\n  // quasi elements, since some parsers accidentally include them.\n  node.expressions.forEach(function (expr, i) {\n    // Rewind from expr.loc.start over any whitespace and the ${ that\n    // precedes the expression. The position of the $ should be the same\n    // as the .loc.end of the preceding quasi element, but some parsers\n    // accidentally include the ${ in the .loc of the quasi element.\n    var dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);\n    if (lines.prevPos(dollarCurlyPos) &&\n        lines.charAt(dollarCurlyPos) === \"{\" &&\n        lines.prevPos(dollarCurlyPos) &&\n        lines.charAt(dollarCurlyPos) === \"$\") {\n      var quasiBefore = node.quasis[i];\n      if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {\n        quasiBefore.loc.end = dollarCurlyPos;\n      }\n    }\n\n    // Likewise, some parsers accidentally include the } that follows\n    // the expression in the .loc of the following quasi element.\n    var rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);\n    if (lines.charAt(rightCurlyPos) === \"}\") {\n      assert.ok(lines.nextPos(rightCurlyPos));\n      // Now rightCurlyPos is technically the position just after the }.\n      var quasiAfter = node.quasis[i + 1];\n      if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {\n        quasiAfter.loc.start = rightCurlyPos;\n      }\n    }\n  });\n}\n\nutil.isExportDeclaration = function (node) {\n  if (node) switch (node.type) {\n  case \"ExportDeclaration\":\n  case \"ExportDefaultSpecifier\":\n  case \"DeclareExportDeclaration\":\n  case \"ExportNamedDeclaration\":\n  case \"ExportAllDeclaration\":\n    return true;\n  }\n\n  return false;\n};\n\nutil.getParentExportDeclaration = function (path) {\n  var parentNode = path.getParentNode();\n  if (path.getName() === \"declaration\" &&\n      util.isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n};\n"]}