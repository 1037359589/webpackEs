{"version":3,"sources":["node-path.js"],"names":[],"mappings":"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","file":"node-path-compiled.js","sourcesContent":["var types = require(\"./types\");\nvar n = types.namedTypes;\nvar b = types.builders;\nvar isNumber = types.builtInTypes.number;\nvar isArray = types.builtInTypes.array;\nvar Path = require(\"./path\");\nvar Scope = require(\"./scope\");\n\nfunction NodePath(value, parentPath, name) {\n    if (!(this instanceof NodePath)) {\n        throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n    }\n    Path.call(this, value, parentPath, name);\n}\n\nvar NPp = NodePath.prototype = Object.create(Path.prototype, {\n    constructor: {\n        value: NodePath,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    }\n});\n\nObject.defineProperties(NPp, {\n    node: {\n        get: function() {\n            Object.defineProperty(this, \"node\", {\n                configurable: true, // Enable deletion.\n                value: this._computeNode()\n            });\n\n            return this.node;\n        }\n    },\n\n    parent: {\n        get: function() {\n            Object.defineProperty(this, \"parent\", {\n                configurable: true, // Enable deletion.\n                value: this._computeParent()\n            });\n\n            return this.parent;\n        }\n    },\n\n    scope: {\n        get: function() {\n            Object.defineProperty(this, \"scope\", {\n                configurable: true, // Enable deletion.\n                value: this._computeScope()\n            });\n\n            return this.scope;\n        }\n    }\n});\n\nNPp.replace = function() {\n    delete this.node;\n    delete this.parent;\n    delete this.scope;\n    return Path.prototype.replace.apply(this, arguments);\n};\n\nNPp.prune = function() {\n    var remainingNodePath = this.parent;\n\n    this.replace();\n\n    return cleanUpNodesAfterPrune(remainingNodePath);\n};\n\n// The value of the first ancestor Path whose value is a Node.\nNPp._computeNode = function() {\n    var value = this.value;\n    if (n.Node.check(value)) {\n        return value;\n    }\n\n    var pp = this.parentPath;\n    return pp && pp.node || null;\n};\n\n// The first ancestor Path whose value is a Node distinct from this.node.\nNPp._computeParent = function() {\n    var value = this.value;\n    var pp = this.parentPath;\n\n    if (!n.Node.check(value)) {\n        while (pp && !n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n        }\n\n        if (pp) {\n            pp = pp.parentPath;\n        }\n    }\n\n    while (pp && !n.Node.check(pp.value)) {\n        pp = pp.parentPath;\n    }\n\n    return pp || null;\n};\n\n// The closest enclosing scope that governs this node.\nNPp._computeScope = function() {\n    var value = this.value;\n    var pp = this.parentPath;\n    var scope = pp && pp.scope;\n\n    if (n.Node.check(value) &&\n        Scope.isEstablishedBy(value)) {\n        scope = new Scope(this, scope);\n    }\n\n    return scope || null;\n};\n\nNPp.getValueProperty = function(name) {\n    return types.getFieldValue(this.value, name);\n};\n\n/**\n * Determine whether this.node needs to be wrapped in parentheses in order\n * for a parser to reproduce the same local AST structure.\n *\n * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n * parse differently.\n *\n * If assumeExpressionContext === true, we don't worry about edge cases\n * like an anonymous FunctionExpression appearing lexically first in its\n * enclosing statement and thus needing parentheses to avoid being parsed\n * as a FunctionDeclaration with a missing name.\n */\nNPp.needsParens = function(assumeExpressionContext) {\n    var pp = this.parentPath;\n    if (!pp) {\n        return false;\n    }\n\n    var node = this.value;\n\n    // Only expressions need parentheses.\n    if (!n.Expression.check(node)) {\n        return false;\n    }\n\n    // Identifiers never need parentheses.\n    if (node.type === \"Identifier\") {\n        return false;\n    }\n\n    while (!n.Node.check(pp.value)) {\n        pp = pp.parentPath;\n        if (!pp) {\n            return false;\n        }\n    }\n\n    var parent = pp.value;\n\n    switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\"\n            && this.name === \"object\"\n            && parent.object === node;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n        switch (parent.type) {\n        case \"CallExpression\":\n            return this.name === \"callee\"\n                && parent.callee === node;\n\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n            return true;\n\n        case \"MemberExpression\":\n            return this.name === \"object\"\n                && parent.object === node;\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n            var po = parent.operator;\n            var pp = PRECEDENCE[po];\n            var no = node.operator;\n            var np = PRECEDENCE[no];\n\n            if (pp > np) {\n                return true;\n            }\n\n            if (pp === np && this.name === \"right\") {\n                if (parent.right !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n\n        default:\n            return false;\n        }\n\n    case \"SequenceExpression\":\n        switch (parent.type) {\n        case \"ForStatement\":\n            // Although parentheses wouldn't hurt around sequence\n            // expressions in the head of for loops, traditional style\n            // dictates that e.g. i++, j++ should not be wrapped with\n            // parentheses.\n            return false;\n\n        case \"ExpressionStatement\":\n            return this.name !== \"expression\";\n\n        default:\n            // Otherwise err on the side of overparenthesization, adding\n            // explicit exceptions above if this proves overzealous.\n            return true;\n        }\n\n    case \"YieldExpression\":\n        switch (parent.type) {\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"CallExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n        case \"ConditionalExpression\":\n        case \"YieldExpression\":\n            return true;\n\n        default:\n            return false;\n        }\n\n    case \"Literal\":\n        return parent.type === \"MemberExpression\"\n            && isNumber.check(node.value)\n            && this.name === \"object\"\n            && parent.object === node;\n\n    case \"AssignmentExpression\":\n    case \"ConditionalExpression\":\n        switch (parent.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n            return true;\n\n        case \"CallExpression\":\n            return this.name === \"callee\"\n                && parent.callee === node;\n\n        case \"ConditionalExpression\":\n            return this.name === \"test\"\n                && parent.test === node;\n\n        case \"MemberExpression\":\n            return this.name === \"object\"\n                && parent.object === node;\n\n        default:\n            return false;\n        }\n\n    default:\n        if (parent.type === \"NewExpression\" &&\n            this.name === \"callee\" &&\n            parent.callee === node) {\n            return containsCallExpression(node);\n        }\n    }\n\n    if (assumeExpressionContext !== true &&\n        !this.canBeFirstInStatement() &&\n        this.firstInStatement())\n        return true;\n\n    return false;\n};\n\nfunction isBinary(node) {\n    return n.BinaryExpression.check(node)\n        || n.LogicalExpression.check(node);\n}\n\nfunction isUnaryLike(node) {\n    return n.UnaryExpression.check(node)\n        // I considered making SpreadElement and SpreadProperty subtypes\n        // of UnaryExpression, but they're not really Expression nodes.\n        || (n.SpreadElement && n.SpreadElement.check(node))\n        || (n.SpreadProperty && n.SpreadProperty.check(node));\n}\n\nvar PRECEDENCE = {};\n[[\"||\"],\n [\"&&\"],\n [\"|\"],\n [\"^\"],\n [\"&\"],\n [\"==\", \"===\", \"!=\", \"!==\"],\n [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n [\">>\", \"<<\", \">>>\"],\n [\"+\", \"-\"],\n [\"*\", \"/\", \"%\"]\n].forEach(function(tier, i) {\n    tier.forEach(function(op) {\n        PRECEDENCE[op] = i;\n    });\n});\n\nfunction containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n        return true;\n    }\n\n    if (isArray.check(node)) {\n        return node.some(containsCallExpression);\n    }\n\n    if (n.Node.check(node)) {\n        return types.someField(node, function(name, child) {\n            return containsCallExpression(child);\n        });\n    }\n\n    return false;\n}\n\nNPp.canBeFirstInStatement = function() {\n    var node = this.node;\n    return !n.FunctionExpression.check(node)\n        && !n.ObjectExpression.check(node);\n};\n\nNPp.firstInStatement = function() {\n    return firstInStatement(this);\n};\n\nfunction firstInStatement(path) {\n    for (var node, parent; path.parent; path = path.parent) {\n        node = path.node;\n        parent = path.parent.node;\n\n        if (n.BlockStatement.check(parent) &&\n            path.parent.name === \"body\" &&\n            path.name === 0) {\n            if (parent.body[0] !== node) {\n                throw new Error(\"Nodes must be equal\");\n            }\n            return true;\n        }\n\n        if (n.ExpressionStatement.check(parent) &&\n            path.name === \"expression\") {\n            if (parent.expression !== node) {\n                throw new Error(\"Nodes must be equal\");\n            }\n            return true;\n        }\n\n        if (n.SequenceExpression.check(parent) &&\n            path.parent.name === \"expressions\" &&\n            path.name === 0) {\n            if (parent.expressions[0] !== node) {\n                throw new Error(\"Nodes must be equal\");\n            }\n            continue;\n        }\n\n        if (n.CallExpression.check(parent) &&\n            path.name === \"callee\") {\n            if (parent.callee !== node) {\n                throw new Error(\"Nodes must be equal\");\n            }\n            continue;\n        }\n\n        if (n.MemberExpression.check(parent) &&\n            path.name === \"object\") {\n            if (parent.object !== node) {\n                throw new Error(\"Nodes must be equal\");\n            }\n            continue;\n        }\n\n        if (n.ConditionalExpression.check(parent) &&\n            path.name === \"test\") {\n            if (parent.test !== node) {\n                throw new Error(\"Nodes must be equal\");\n            }\n            continue;\n        }\n\n        if (isBinary(parent) &&\n            path.name === \"left\") {\n            if (parent.left !== node) {\n                throw new Error(\"Nodes must be equal\");\n            }\n            continue;\n        }\n\n        if (n.UnaryExpression.check(parent) &&\n            !parent.prefix &&\n            path.name === \"argument\") {\n            if (parent.argument !== node) {\n                throw new Error(\"Nodes must be equal\");\n            }\n            continue;\n        }\n\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n */\nfunction cleanUpNodesAfterPrune(remainingNodePath) {\n    if (n.VariableDeclaration.check(remainingNodePath.node)) {\n        var declarations = remainingNodePath.get('declarations').value;\n        if (!declarations || declarations.length === 0) {\n            return remainingNodePath.prune();\n        }\n    } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n        if (!remainingNodePath.get('expression').value) {\n            return remainingNodePath.prune();\n        }\n    } else if (n.IfStatement.check(remainingNodePath.node)) {\n        cleanUpIfStatementAfterPrune(remainingNodePath);\n    }\n\n    return remainingNodePath;\n}\n\nfunction cleanUpIfStatementAfterPrune(ifStatement) {\n    var testExpression = ifStatement.get('test').value;\n    var alternate = ifStatement.get('alternate').value;\n    var consequent = ifStatement.get('consequent').value;\n\n    if (!consequent && !alternate) {\n        var testExpressionStatement = b.expressionStatement(testExpression);\n\n        ifStatement.replace(testExpressionStatement);\n    } else if (!consequent && alternate) {\n        var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n\n        if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n            negatedTestExpression = testExpression.argument;\n        }\n\n        ifStatement.get(\"test\").replace(negatedTestExpression);\n        ifStatement.get(\"consequent\").replace(alternate);\n        ifStatement.get(\"alternate\").replace();\n    }\n}\n\nmodule.exports = NodePath;\n"]}