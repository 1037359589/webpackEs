{"version":3,"sources":["scope.js"],"names":[],"mappings":"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","file":"scope-compiled.js","sourcesContent":["var types = require(\"./types\");\nvar Type = types.Type;\nvar namedTypes = types.namedTypes;\nvar Node = namedTypes.Node;\nvar Expression = namedTypes.Expression;\nvar isArray = types.builtInTypes.array;\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar b = types.builders;\n\nfunction Scope(path, parentScope) {\n    if (!(this instanceof Scope)) {\n        throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n    }\n    if (!(path instanceof require(\"./node-path\"))) {\n        throw new Error(\"\");\n    }\n    ScopeType.assert(path.value);\n\n    var depth;\n\n    if (parentScope) {\n        if (!(parentScope instanceof Scope)) {\n            throw new Error(\"\");\n        }\n        depth = parentScope.depth + 1;\n    } else {\n        parentScope = null;\n        depth = 0;\n    }\n\n    Object.defineProperties(this, {\n        path: { value: path },\n        node: { value: path.value },\n        isGlobal: { value: !parentScope, enumerable: true },\n        depth: { value: depth },\n        parent: { value: parentScope },\n        bindings: { value: {} },\n        types: { value: {} },\n    });\n}\n\nvar scopeTypes = [\n    // Program nodes introduce global scopes.\n    namedTypes.Program,\n\n    // Function is the supertype of FunctionExpression,\n    // FunctionDeclaration, ArrowExpression, etc.\n    namedTypes.Function,\n\n    // In case you didn't know, the caught parameter shadows any variable\n    // of the same name in an outer scope.\n    namedTypes.CatchClause\n];\n\nvar ScopeType = Type.or.apply(Type, scopeTypes);\n\nScope.isEstablishedBy = function(node) {\n    return ScopeType.check(node);\n};\n\nvar Sp = Scope.prototype;\n\n// Will be overridden after an instance lazily calls scanScope.\nSp.didScan = false;\n\nSp.declares = function(name) {\n    this.scan();\n    return hasOwn.call(this.bindings, name);\n};\n\nSp.declaresType = function(name) {\n    this.scan();\n    return hasOwn.call(this.types, name);\n};\n\nSp.declareTemporary = function(prefix) {\n    if (prefix) {\n        if (!/^[a-z$_]/i.test(prefix)) {\n            throw new Error(\"\");\n        }\n    } else {\n        prefix = \"t$\";\n    }\n\n    // Include this.depth in the name to make sure the name does not\n    // collide with any variables in nested/enclosing scopes.\n    prefix += this.depth.toString(36) + \"$\";\n\n    this.scan();\n\n    var index = 0;\n    while (this.declares(prefix + index)) {\n        ++index;\n    }\n\n    var name = prefix + index;\n    return this.bindings[name] = types.builders.identifier(name);\n};\n\nSp.injectTemporary = function(identifier, init) {\n    identifier || (identifier = this.declareTemporary());\n\n    var bodyPath = this.path.get(\"body\");\n    if (namedTypes.BlockStatement.check(bodyPath.value)) {\n        bodyPath = bodyPath.get(\"body\");\n    }\n\n    bodyPath.unshift(\n        b.variableDeclaration(\n            \"var\",\n            [b.variableDeclarator(identifier, init || null)]\n        )\n    );\n\n    return identifier;\n};\n\nSp.scan = function(force) {\n    if (force || !this.didScan) {\n        for (var name in this.bindings) {\n            // Empty out this.bindings, just in cases.\n            delete this.bindings[name];\n        }\n        scanScope(this.path, this.bindings, this.types);\n        this.didScan = true;\n    }\n};\n\nSp.getBindings = function () {\n    this.scan();\n    return this.bindings;\n};\n\nSp.getTypes = function () {\n    this.scan();\n    return this.types;\n};\n\nfunction scanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n    ScopeType.assert(node);\n\n    if (namedTypes.CatchClause.check(node)) {\n        // A catch clause establishes a new scope but the only variable\n        // bound in that scope is the catch parameter. Any other\n        // declarations create bindings in the outer scope.\n        addPattern(path.get(\"param\"), bindings);\n\n    } else {\n        recursiveScanScope(path, bindings, scopeTypes);\n    }\n}\n\nfunction recursiveScanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n\n    if (path.parent &&\n        namedTypes.FunctionExpression.check(path.parent.node) &&\n        path.parent.node.id) {\n        addPattern(path.parent.get(\"id\"), bindings);\n    }\n\n    if (!node) {\n        // None of the remaining cases matter if node is falsy.\n\n    } else if (isArray.check(node)) {\n        path.each(function(childPath) {\n            recursiveScanChild(childPath, bindings, scopeTypes);\n        });\n\n    } else if (namedTypes.Function.check(node)) {\n        path.get(\"params\").each(function(paramPath) {\n            addPattern(paramPath, bindings);\n        });\n\n        recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n\n    } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) {\n        addTypePattern(path.get(\"id\"), scopeTypes);\n\n    } else if (namedTypes.VariableDeclarator.check(node)) {\n        addPattern(path.get(\"id\"), bindings);\n        recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n\n    } else if (node.type === \"ImportSpecifier\" ||\n               node.type === \"ImportNamespaceSpecifier\" ||\n               node.type === \"ImportDefaultSpecifier\") {\n        addPattern(\n            // Esprima used to use the .name field to refer to the local\n            // binding identifier for ImportSpecifier nodes, but .id for\n            // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n            // ESTree/Acorn/ESpree use .local for all three node types.\n            path.get(node.local ? \"local\" :\n                     node.name ? \"name\" : \"id\"),\n            bindings\n        );\n\n    } else if (Node.check(node) && !Expression.check(node)) {\n        types.eachField(node, function(name, child) {\n            var childPath = path.get(name);\n            if (childPath.value !== child) {\n                throw new Error(\"\");\n            }\n            recursiveScanChild(childPath, bindings, scopeTypes);\n        });\n    }\n}\n\nfunction recursiveScanChild(path, bindings, scopeTypes) {\n    var node = path.value;\n\n    if (!node || Expression.check(node)) {\n        // Ignore falsy values and Expressions.\n\n    } else if (namedTypes.FunctionDeclaration.check(node)) {\n        addPattern(path.get(\"id\"), bindings);\n\n    } else if (namedTypes.ClassDeclaration &&\n               namedTypes.ClassDeclaration.check(node)) {\n        addPattern(path.get(\"id\"), bindings);\n\n    } else if (ScopeType.check(node)) {\n        if (namedTypes.CatchClause.check(node)) {\n            var catchParamName = node.param.name;\n            var hadBinding = hasOwn.call(bindings, catchParamName);\n\n            // Any declarations that occur inside the catch body that do\n            // not have the same name as the catch parameter should count\n            // as bindings in the outer scope.\n            recursiveScanScope(path.get(\"body\"), bindings, scopeTypes);\n\n            // If a new binding matching the catch parameter name was\n            // created while scanning the catch body, ignore it because it\n            // actually refers to the catch parameter and not the outer\n            // scope that we're currently scanning.\n            if (!hadBinding) {\n                delete bindings[catchParamName];\n            }\n        }\n\n    } else {\n        recursiveScanScope(path, bindings, scopeTypes);\n    }\n}\n\nfunction addPattern(patternPath, bindings) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n\n    if (namedTypes.Identifier.check(pattern)) {\n        if (hasOwn.call(bindings, pattern.name)) {\n            bindings[pattern.name].push(patternPath);\n        } else {\n            bindings[pattern.name] = [patternPath];\n        }\n\n    } else if (namedTypes.ObjectPattern &&\n               namedTypes.ObjectPattern.check(pattern)) {\n        patternPath.get('properties').each(function(propertyPath) {\n            var property = propertyPath.value;\n            if (namedTypes.Pattern.check(property)) {\n                addPattern(propertyPath, bindings);\n            } else  if (namedTypes.Property.check(property)) {\n                addPattern(propertyPath.get('value'), bindings);\n            } else if (namedTypes.SpreadProperty &&\n                       namedTypes.SpreadProperty.check(property)) {\n                addPattern(propertyPath.get('argument'), bindings);\n            }\n        });\n\n    } else if (namedTypes.ArrayPattern &&\n               namedTypes.ArrayPattern.check(pattern)) {\n        patternPath.get('elements').each(function(elementPath) {\n            var element = elementPath.value;\n            if (namedTypes.Pattern.check(element)) {\n                addPattern(elementPath, bindings);\n            } else if (namedTypes.SpreadElement &&\n                       namedTypes.SpreadElement.check(element)) {\n                addPattern(elementPath.get(\"argument\"), bindings);\n            }\n        });\n\n    } else if (namedTypes.PropertyPattern &&\n               namedTypes.PropertyPattern.check(pattern)) {\n        addPattern(patternPath.get('pattern'), bindings);\n\n    } else if ((namedTypes.SpreadElementPattern &&\n                namedTypes.SpreadElementPattern.check(pattern)) ||\n               (namedTypes.SpreadPropertyPattern &&\n                namedTypes.SpreadPropertyPattern.check(pattern))) {\n        addPattern(patternPath.get('argument'), bindings);\n    }\n}\n\nfunction addTypePattern(patternPath, types) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n\n    if (namedTypes.Identifier.check(pattern)) {\n        if (hasOwn.call(types, pattern.name)) {\n            types[pattern.name].push(patternPath);\n        } else {\n            types[pattern.name] = [patternPath];\n        }\n\n    }\n}\n\nSp.lookup = function(name) {\n    for (var scope = this; scope; scope = scope.parent)\n        if (scope.declares(name))\n            break;\n    return scope;\n};\n\nSp.lookupType = function(name) {\n    for (var scope = this; scope; scope = scope.parent)\n        if (scope.declaresType(name))\n            break;\n    return scope;\n};\n\nSp.getGlobalScope = function() {\n    var scope = this;\n    while (!scope.isGlobal)\n        scope = scope.parent;\n    return scope;\n};\n\nmodule.exports = Scope;\n"]}