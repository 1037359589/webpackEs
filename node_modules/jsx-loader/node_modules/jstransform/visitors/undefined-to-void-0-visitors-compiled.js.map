{"version":3,"sources":["undefined-to-void-0-visitors.js"],"names":[],"mappings":";;;;;;;;;AASA,IAAI,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC;AAC1C,IAAI,KAAK,GAAG,OAAO,CAAC,cAAc,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAC,AAwEpC,SAAS,wBAAwB,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE;AAC7D,OAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,UAAS,KAAK,EAAE;AAClD,WAAO,UAAU,CAAC;GACnB,CAAC,CAAC;CACJ;;AAED,wBAAwB,CAAC,IAAI,GAAG,UAAS,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE;AAC1D,MACE,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,UAAU,IAC1B,IAAI,CAAC,IAAI,KAAK,WAAW,IACzB,CAAC,KAAK,CAAC,uBAAuB,CAAC,WAAW,EAAE,KAAK,CAAC,EACvD;AACA,QAAI,IAAI,CAAC,CAAC,CAAC,EAAE;AACX,cAAQ,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI;AAClB,aAAK,MAAM,CAAC,mBAAmB,CAAC;AAChC,aAAK,MAAM,CAAC,kBAAkB,CAAC;AAC/B,aAAK,MAAM,CAAC,uBAAuB;;AAEjC,cAAI,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;AACzB,mBAAO,KAAK,CAAC;WACd;AACD,gBAAM;AAAA,AACR,aAAK,MAAM,CAAC,oBAAoB;;AAE9B,cAAI,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;AACzB,kBAAM,IAAI,KAAK,CACb,qCAAqC,GACjC,2CAA2C,CAChD,CAAC;WACH;AACD,gBAAM;AAAA,AACR,aAAK,MAAM,CAAC,gBAAgB;;AAE1B,cAAI,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;AAClD,mBAAO,KAAK,CAAC;WACd;AACD,gBAAM;AAAA,AACR,aAAK,MAAM,CAAC,kBAAkB;;AAE5B,cAAI,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;AACzB,mBAAO,KAAK,CAAC;WACd;AACD,gBAAM;AAAA,AACR,aAAK,MAAM,CAAC,QAAQ;;AAElB,cAAI,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;AACxB,mBAAO,KAAK,CAAC;WACd;AACD,gBAAM;AAAA,OACT;KACF;AACD,WAAO,IAAI,CAAC;GACb;AACD,SAAO,KAAK,CAAC;CACd,CAAC;;AAEF,OAAO,CAAC,WAAW,GAAG,CACpB,wBAAwB,CACzB,CAAC","file":"undefined-to-void-0-visitors-compiled.js","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar Syntax = require('esprima-fb').Syntax;\nvar utils = require('../src/utils');\n\n/**\n * Replaces `undefined` with `(void 0)` when it appears as an rvalue and is\n * undeclared in the lexical scope.\n *\n * Example:\n *\n * (function() {\n *   foo.undefined = bar;\n *   ({undefined: foo});\n *\n *   var bar = undefined;\n *   bar = undefined;\n *   foo.bar = undefined;\n *   undefined.foo = bar;\n *   foo[undefined] = bar;\n *   ({foo: undefined});\n * })(undefined);\n *\n * (function(undefined) { // declared here\n *   return undefined;\n * })(1);\n *\n * (function() {\n *   var undefined;       // declared here\n *   undefined = 1;       // assignment to declared variable\n *   return undefined;\n * })();\n *\n * (function(undefined) { // declared here\n *   return (function() {\n *     return undefined;  // respects lexical scope\n *   })();\n * })();\n *\n * Becomes:\n *\n * (function() {\n *   foo.undefined = bar;\n *   ({undefined: foo});\n *\n *   var bar = (void 0);\n *   bar = (void 0);\n *   foo.bar = (void 0);\n *   (void 0).foo = bar;\n *   foo[(void 0)] = bar;\n *   ({foo: (void 0)});\n * })((void 0));\n *\n * (function(undefined) { // declared here\n *   return undefined;\n * })(1);\n *\n * (function() {\n *   var undefined;       // declared here\n *   undefined = 1;       // assignment to declared variable\n *   return undefined;\n * })();\n *\n * (function(undefined) { // declared here\n *   return (function() {\n *     return undefined;  // respects lexical scope\n *   })();\n * })();\n *\n *\n *\n * NOTE: Any assignment to `undefined` where `undefined` is not declared in the\n * lexical scope will result in an exception.\n */\n\nfunction visitIdentifierUndefined(traverse, node, path, state) {\n  utils.catchup(node.range[1], state, function(value) {\n    return '(void 0)';\n  });\n}\n\nvisitIdentifierUndefined.test = function(node, path, state) {\n  if (\n    node.type === Syntax.Identifier\n      && node.name === 'undefined'\n      && !utils.identWithinLexicalScope('undefined', state)\n  ) {\n    if (path[0]) {\n      switch (path[0].type) {\n        case Syntax.FunctionDeclaration:\n        case Syntax.FunctionExpression:\n        case Syntax.ArrowFunctionExpression:\n          // skips: function params\n          if (node !== path[0].body) {\n            return false;\n          }\n          break;\n        case Syntax.AssignmentExpression:\n          // throws for: `undefined = foo` (where `undefined` is not declared)\n          if (node === path[0].left) {\n            throw new Error(\n              'Illegal assignment to `undefined`. '\n                + 'This breaks assumptions of the transform.'\n            );\n          }\n          break;\n        case Syntax.MemberExpression:\n          // skips: `foo.undefined` but not `foo[undefined]`\n          if (node === path[0].property && !path[0].computed) {\n            return false;\n          }\n          break;\n        case Syntax.VariableDeclarator:\n          // skips: `var undefined`\n          if (node !== path[0].init) {\n            return false;\n          }\n          break;\n        case Syntax.Property:\n          // skips: `undefined: foo`\n          if (node === path[0].key) {\n            return false;\n          }\n          break;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\nexports.visitorList = [\n  visitIdentifierUndefined\n];\n"]}