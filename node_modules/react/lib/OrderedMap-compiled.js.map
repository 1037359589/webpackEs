{"version":3,"sources":["OrderedMap.js"],"names":[],"mappings":"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","file":"OrderedMap-compiled.js","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule OrderedMap\n */\n\n'use strict';\n\nvar assign = require('./Object.assign');\nvar invariant = require('fbjs/lib/invariant');\n\nvar PREFIX = 'key:';\n\n/**\n * Utility to extract a backing object from an initialization `Array`, allowing\n * the caller to assist in resolving the unique ID for each entry via the\n * `keyExtractor` callback. The `keyExtractor` must extract non-empty strings or\n * numbers.\n * @param {Array<Object!>} arr Array of items.\n * @param {function} keyExtractor Extracts a unique key from each item.\n * @return {Object} Map from unique key to originating value that the key was\n * extracted from.\n * @throws Exception if the initialization array has duplicate extracted keys.\n */\nfunction extractObjectFromArray(arr, keyExtractor) {\n  var normalizedObj = {};\n  for (var i = 0; i < arr.length; i++) {\n    var item = arr[i];\n    var key = keyExtractor(item);\n    assertValidPublicKey(key);\n    var normalizedKey = PREFIX + key;\n    !!(normalizedKey in normalizedObj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap: IDs returned by the key extraction function must be unique.') : invariant(false) : undefined;\n    normalizedObj[normalizedKey] = item;\n  }\n  return normalizedObj;\n}\n\n/**\n * Utility class for mappings with ordering. This class is to be used in an\n * immutable manner. A `OrderedMap` is very much like the native JavaScript\n * object, where keys map to values via the `get()` function. Also, like the\n * native JavaScript object, there is an ordering associated with the mapping.\n * This class is helpful because it eliminates many of the pitfalls that come\n * with the native JavaScript ordered mappings. Specifically, there are\n * inconsistencies with numeric keys in some JavaScript implementations\n * (enumeration ordering). This class protects against those pitfalls and\n * provides functional utilities for dealing with these `OrderedMap`s.\n *\n * - TODO:\n * - orderedMergeExclusive: Merges mutually exclusive `OrderedMap`s.\n * - mapReverse().\n *\n * @class {OrderedMap}\n * @constructor {OrderedMap}\n * @param {Object} normalizedObj Object that is known to be a defensive copy of\n * caller supplied data. We require a defensive copy to guard against callers\n * mutating.  It is also assumed that the keys of `normalizedObj` have been\n * normalized and do not contain any numeric-appearing strings.\n * @param {number} computedLength The precomputed length of `_normalizedObj`\n * keys.\n * @private\n */\nfunction OrderedMapImpl(normalizedObj, computedLength) {\n  this._normalizedObj = normalizedObj;\n  this._computedPositions = null;\n  this.length = computedLength;\n}\n\n/**\n * Validates a \"public\" key - that is, one that the public facing API supplies.\n * The key is then normalized for internal storage. In order to be considered\n * valid, all keys must be non-empty, defined, non-null strings or numbers.\n *\n * @param {string?} key Validates that the key is suitable for use in a\n * `OrderedMap`.\n * @throws Error if key is not appropriate for use in `OrderedMap`.\n */\nfunction assertValidPublicKey(key) {\n  !(key !== '' && (typeof key === 'string' || typeof key === 'number')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap: Key must be non-empty, non-null string or number.') : invariant(false) : undefined;\n}\n\n/**\n * Validates that arguments to range operations are within the correct limits.\n *\n * @param {number} start Start of range.\n * @param {number} length Length of range.\n * @param {number} actualLen Actual length of range that should not be\n * exceeded.\n * @throws Error if range arguments are out of bounds.\n */\nfunction assertValidRangeIndices(start, length, actualLen) {\n  !(typeof start === 'number' && typeof length === 'number' && length >= 0 && start >= 0 && start + length <= actualLen) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap: `mapRange` and `forEachRange` expect non-negative start and ' + 'length arguments within the bounds of the instance.') : invariant(false) : undefined;\n}\n\n/**\n * Merges two \"normalized\" objects (objects who's key have been normalized) into\n * a `OrderedMap`.\n *\n * @param {Object} a Object of key value pairs.\n * @param {Object} b Object of key value pairs.\n * @return {OrderedMap} new `OrderedMap` that results in merging `a` and `b`.\n */\nfunction _fromNormalizedObjects(a, b) {\n  // Second optional, both must be plain JavaScript objects.\n  !(a && a.constructor === Object && (!b || b.constructor === Object)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap: Corrupted instance of OrderedMap detected.') : invariant(false) : undefined;\n\n  var newSet = {};\n  var length = 0;\n  var key;\n  for (key in a) {\n    if (a.hasOwnProperty(key)) {\n      newSet[key] = a[key];\n      length++;\n    }\n  }\n\n  for (key in b) {\n    if (b.hasOwnProperty(key)) {\n      // Increment length if not already added via first object (a)\n      if (!(key in newSet)) {\n        length++;\n      }\n      newSet[key] = b[key];\n    }\n  }\n  return new OrderedMapImpl(newSet, length);\n}\n\n/**\n * Methods for `OrderedMap` instances.\n *\n * @lends OrderedMap.prototype\n * TODO: Make this data structure lazy, unify with LazyArray.\n * TODO: Unify this with ImmutableObject - it is to be used immutably.\n * TODO: If so, consider providing `fromObject` API.\n * TODO: Create faster implementation of merging/mapping from original Array,\n * without having to first create an object - simply for the sake of merging.\n */\nvar OrderedMapMethods = {\n\n  /**\n   * Returns whether or not a given key is present in the map.\n   *\n   * @param {string} key Valid string key to lookup membership for.\n   * @return {boolean} Whether or not `key` is a member of the map.\n   * @throws Error if provided known invalid key.\n   */\n  has: function (key) {\n    assertValidPublicKey(key);\n    var normalizedKey = PREFIX + key;\n    return normalizedKey in this._normalizedObj;\n  },\n\n  /**\n   * Returns the object for a given key, or `undefined` if not present. To\n   * distinguish an undefined entry vs not being in the set, use `has()`.\n   *\n   * @param {string} key String key to lookup the value for.\n   * @return {Object?} Object at key `key`, or undefined if not in map.\n   * @throws Error if provided known invalid key.\n   */\n  get: function (key) {\n    assertValidPublicKey(key);\n    var normalizedKey = PREFIX + key;\n    return this.has(key) ? this._normalizedObj[normalizedKey] : undefined;\n  },\n\n  /**\n   * Merges, appending new keys to the end of the ordering. Keys in `orderedMap`\n   * that are redundant with `this`, maintain the same ordering index that they\n   * had in `this`.  This is how standard JavaScript object merging would work.\n   * If you wish to prepend a `OrderedMap` to the beginning of another\n   * `OrderedMap` then simply reverse the order of operation. This is the analog\n   * to `merge(x, y)`.\n   *\n   * @param {OrderedMap} orderedMap OrderedMap to merge onto the end.\n   * @return {OrderedMap} New OrderedMap that represents the result of the\n   * merge.\n   */\n  merge: function (orderedMap) {\n    !(orderedMap instanceof OrderedMapImpl) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap.merge(...): Expected an OrderedMap instance.') : invariant(false) : undefined;\n    return _fromNormalizedObjects(this._normalizedObj, orderedMap._normalizedObj);\n  },\n\n  /**\n   * Functional map API. Returns a new `OrderedMap`.\n   *\n   * @param {Function} cb Callback to invoke for each item.\n   * @param {Object?=} context Context to invoke callback from.\n   * @return {OrderedMap} OrderedMap that results from mapping.\n   */\n  map: function (cb, context) {\n    return this.mapRange(cb, 0, this.length, context);\n  },\n\n  /**\n   * The callback `cb` is invoked with the arguments (item, key,\n   * indexInOriginal).\n   *\n   * @param {Function} cb Determines result for each item.\n   * @param {number} start Start index of map range.\n   * @param {end} length End index of map range.\n   * @param {*!?} context Context of callback invocation.\n   * @return {OrderedMap} OrderedMap resulting from mapping the range.\n   */\n  mapRange: function (cb, start, length, context) {\n    var thisSet = this._normalizedObj;\n    var newSet = {};\n    var i = 0;\n    assertValidRangeIndices(start, length, this.length);\n    var end = start + length - 1;\n    for (var key in thisSet) {\n      if (thisSet.hasOwnProperty(key)) {\n        if (i >= start) {\n          if (i > end) {\n            break;\n          }\n          var item = thisSet[key];\n          newSet[key] = cb.call(context, item, key.substr(PREFIX.length), i);\n        }\n        i++;\n      }\n    }\n    return new OrderedMapImpl(newSet, length);\n  },\n\n  /**\n   * Function filter API. Returns new `OrderedMap`.\n   *\n   * @param {Function} cb Callback to invoke for each item.\n   * @param {Object?=} context Context to invoke callback from.\n   * @return {OrderedMap} OrderedMap that results from filtering.\n   */\n  filter: function (cb, context) {\n    return this.filterRange(cb, 0, this.length, context);\n  },\n\n  /**\n   * The callback `cb` is invoked with the arguments (item, key,\n   * indexInOriginal).\n   *\n   * @param {Function} cb Returns true if item should be in result.\n   * @param {number} start Start index of filter range.\n   * @param {number} length End index of map range.\n   * @param {*!?} context Context of callback invocation.\n   * @return {OrderedMap} OrderedMap resulting from filtering the range.\n   */\n  filterRange: function (cb, start, length, context) {\n    var newSet = {};\n    var newSetLength = 0;\n    this.forEachRange(function (item, key, originalIndex) {\n      if (cb.call(context, item, key, originalIndex)) {\n        var normalizedKey = PREFIX + key;\n        newSet[normalizedKey] = item;\n        newSetLength++;\n      }\n    }, start, length);\n    return new OrderedMapImpl(newSet, newSetLength);\n  },\n\n  forEach: function (cb, context) {\n    this.forEachRange(cb, 0, this.length, context);\n  },\n\n  forEachRange: function (cb, start, length, context) {\n    assertValidRangeIndices(start, length, this.length);\n    var thisSet = this._normalizedObj;\n    var i = 0;\n    var end = start + length - 1;\n    for (var key in thisSet) {\n      if (thisSet.hasOwnProperty(key)) {\n        if (i >= start) {\n          if (i > end) {\n            break;\n          }\n          var item = thisSet[key];\n          cb.call(context, item, key.substr(PREFIX.length), i);\n        }\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Even though `mapRange`/`forEachKeyRange` allow zero length mappings, we'll\n   * impose an additional restriction here that the length of mapping be greater\n   * than zero - the only reason is that there are many ways to express length\n   * zero in terms of two keys and that is confusing.\n   */\n  mapKeyRange: function (cb, startKey, endKey, context) {\n    var startIndex = this.indexOfKey(startKey);\n    var endIndex = this.indexOfKey(endKey);\n    !(startIndex !== undefined && endIndex !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mapKeyRange must be given keys that are present.') : invariant(false) : undefined;\n    !(endIndex >= startIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap.mapKeyRange(...): `endKey` must not come before `startIndex`.') : invariant(false) : undefined;\n    return this.mapRange(cb, startIndex, endIndex - startIndex + 1, context);\n  },\n\n  forEachKeyRange: function (cb, startKey, endKey, context) {\n    var startIndex = this.indexOfKey(startKey);\n    var endIndex = this.indexOfKey(endKey);\n    !(startIndex !== undefined && endIndex !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'forEachKeyRange must be given keys that are present.') : invariant(false) : undefined;\n    !(endIndex >= startIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap.forEachKeyRange(...): `endKey` must not come before ' + '`startIndex`.') : invariant(false) : undefined;\n    this.forEachRange(cb, startIndex, endIndex - startIndex + 1, context);\n  },\n\n  /**\n   * @param {number} pos Index to search for key at.\n   * @return {string|undefined} Either the key at index `pos` or undefined if\n   * not in map.\n   */\n  keyAtIndex: function (pos) {\n    var computedPositions = this._getOrComputePositions();\n    var keyAtPos = computedPositions.keyByIndex[pos];\n    return keyAtPos ? keyAtPos.substr(PREFIX.length) : undefined;\n  },\n\n  /**\n   * @param {string} key String key from which to find the next key.\n   * @return {string|undefined} Either the next key, or undefined if there is no\n   * next key.\n   * @throws Error if `key` is not in this `OrderedMap`.\n   */\n  keyAfter: function (key) {\n    return this.nthKeyAfter(key, 1);\n  },\n\n  /**\n   * @param {string} key String key from which to find the preceding key.\n   * @return {string|undefined} Either the preceding key, or undefined if there\n   * is no preceding.key.\n   * @throws Error if `key` is not in this `OrderedMap`.\n   */\n  keyBefore: function (key) {\n    return this.nthKeyBefore(key, 1);\n  },\n\n  /**\n   * @param {string} key String key from which to find a following key.\n   * @param {number} n Distance to scan forward after `key`.\n   * @return {string|undefined} Either the nth key after `key`, or undefined if\n   * there is no next key.\n   * @throws Error if `key` is not in this `OrderedMap`.\n   */\n  nthKeyAfter: function (key, n) {\n    var curIndex = this.indexOfKey(key);\n    !(curIndex !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap.nthKeyAfter: The key `%s` does not exist in this instance.', key) : invariant(false) : undefined;\n    return this.keyAtIndex(curIndex + n);\n  },\n\n  /**\n   * @param {string} key String key from which to find a preceding key.\n   * @param {number} n Distance to scan backwards before `key`.\n   * @return {string|undefined} Either the nth key before `key`, or undefined if\n   * there is no previous key.\n   * @throws Error if `key` is not in this `OrderedMap`.\n   */\n  nthKeyBefore: function (key, n) {\n    return this.nthKeyAfter(key, -n);\n  },\n\n  /**\n   * @param {string} key Key to find the index of.\n   * @return {number|undefined} Index of the provided key, or `undefined` if the\n   * key is not found.\n   */\n  indexOfKey: function (key) {\n    assertValidPublicKey(key);\n    var normalizedKey = PREFIX + key;\n    var computedPositions = this._getOrComputePositions();\n    var computedPosition = computedPositions.indexByKey[normalizedKey];\n    // Just writing it this way to make it clear this is intentional.\n    return computedPosition === undefined ? undefined : computedPosition;\n  },\n\n  /**\n   * @return {Array} An ordered array of this object's values.\n   */\n  toArray: function () {\n    var result = [];\n    var thisSet = this._normalizedObj;\n    for (var key in thisSet) {\n      if (thisSet.hasOwnProperty(key)) {\n        result.push(thisSet[key]);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * Finds the key at a given position, or indicates via `undefined` that that\n   * position does not exist in the `OrderedMap`. It is appropriate to return\n   * undefined, indicating that the key doesn't exist in the `OrderedMap`\n   * because `undefined` is not ever a valid `OrderedMap` key.\n   *\n   * @private\n   * @return {string?} Name of the item at position `pos`, or `undefined` if\n   * there is no item at that position.\n   */\n  _getOrComputePositions: function () {\n    // TODO: Entertain computing this at construction time in some less\n    // performance critical paths.\n    var computedPositions = this._computedPositions;\n    if (!computedPositions) {\n      this._computePositions();\n    }\n    return this._computedPositions;\n  },\n\n  /**\n   * Precomputes the index/key mapping for future lookup. Since `OrderedMap`s\n   * are immutable, there is only ever a need to perform this once.\n   * @private\n   */\n  _computePositions: function () {\n    this._computedPositions = {\n      keyByIndex: {},\n      indexByKey: {}\n    };\n    var keyByIndex = this._computedPositions.keyByIndex;\n    var indexByKey = this._computedPositions.indexByKey;\n    var index = 0;\n    var thisSet = this._normalizedObj;\n    for (var key in thisSet) {\n      if (thisSet.hasOwnProperty(key)) {\n        keyByIndex[index] = key;\n        indexByKey[key] = index;\n        index++;\n      }\n    }\n  }\n};\n\nassign(OrderedMapImpl.prototype, OrderedMapMethods);\n\nvar OrderedMap = {\n  from: function (orderedMap) {\n    !(orderedMap instanceof OrderedMapImpl) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap.from(...): Expected an OrderedMap instance.') : invariant(false) : undefined;\n    return _fromNormalizedObjects(orderedMap._normalizedObj, null);\n  },\n\n  fromArray: function (arr, keyExtractor) {\n    !Array.isArray(arr) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap.fromArray(...): First argument must be an array.') : invariant(false) : undefined;\n    !(typeof keyExtractor === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'OrderedMap.fromArray(...): Second argument must be a function used ' + 'to determine the unique key for each entry.') : invariant(false) : undefined;\n    return new OrderedMapImpl(extractObjectFromArray(arr, keyExtractor), arr.length);\n  }\n};\n\nmodule.exports = OrderedMap;"]}