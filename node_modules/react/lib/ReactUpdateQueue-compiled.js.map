{"version":3,"sources":["ReactUpdateQueue.js"],"names":[],"mappings":"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","file":"ReactUpdateQueue-compiled.js","sourcesContent":["/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n\n'use strict';\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactElement = require('./ReactElement');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\n\nfunction enqueueUpdate(internalInstance) {\n  ReactUpdates.enqueueUpdate(internalInstance);\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;\n    }\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n    var internalInstance = ReactInstanceMap.get(publicInstance);\n    if (internalInstance) {\n      // During componentWillMount and render this will still be null but after\n      // that will always render to something. At least for now. So we can use\n      // this hack.\n      return !!internalInstance._renderedComponent;\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n    if (!internalInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueCallbackInternal: function (internalInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function (publicInstance, partialProps) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');\n    if (!internalInstance) {\n      return;\n    }\n    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);\n  },\n\n  enqueueSetPropsInternal: function (internalInstance, partialProps) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    var props = assign({}, element.props, partialProps);\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function (publicInstance, props) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');\n    if (!internalInstance) {\n      return;\n    }\n    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);\n  },\n\n  enqueueReplacePropsInternal: function (internalInstance, props) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  enqueueElementInternal: function (internalInstance, newElement) {\n    internalInstance._pendingElement = newElement;\n    enqueueUpdate(internalInstance);\n  }\n\n};\n\nmodule.exports = ReactUpdateQueue;"]}