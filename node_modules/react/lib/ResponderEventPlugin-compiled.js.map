{"version":3,"sources":["ResponderEventPlugin.js"],"names":[],"mappings":"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","file":"ResponderEventPlugin-compiled.js","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ResponderEventPlugin\n */\n\n'use strict';\n\nvar EventConstants = require('./EventConstants');\nvar EventPluginUtils = require('./EventPluginUtils');\nvar EventPropagators = require('./EventPropagators');\nvar ReactInstanceHandles = require('./ReactInstanceHandles');\nvar ResponderSyntheticEvent = require('./ResponderSyntheticEvent');\nvar ResponderTouchHistoryStore = require('./ResponderTouchHistoryStore');\n\nvar accumulate = require('./accumulate');\nvar invariant = require('fbjs/lib/invariant');\nvar keyOf = require('fbjs/lib/keyOf');\n\nvar isStartish = EventPluginUtils.isStartish;\nvar isMoveish = EventPluginUtils.isMoveish;\nvar isEndish = EventPluginUtils.isEndish;\nvar executeDirectDispatch = EventPluginUtils.executeDirectDispatch;\nvar hasDispatches = EventPluginUtils.hasDispatches;\nvar executeDispatchesInOrderStopAtTrue = EventPluginUtils.executeDispatchesInOrderStopAtTrue;\n\n/**\n * ID of element that should respond to touch/move types of interactions, as\n * indicated explicitly by relevant callbacks.\n */\nvar responderID = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * the selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\n/**\n * Last reported number of active touches.\n */\nvar previousActiveTouches = 0;\n\nvar changeResponder = function (nextResponderID, blockNativeResponder) {\n  var oldResponderID = responderID;\n  responderID = nextResponderID;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderID, nextResponderID, blockNativeResponder);\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onStartShouldSetResponder: null }),\n      captured: keyOf({ onStartShouldSetResponderCapture: null })\n    }\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occured during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onScrollShouldSetResponder: null }),\n      captured: keyOf({ onScrollShouldSetResponderCapture: null })\n    }\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onSelectionChangeShouldSetResponder: null }),\n      captured: keyOf({ onSelectionChangeShouldSetResponderCapture: null })\n    }\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onMoveShouldSetResponder: null }),\n      captured: keyOf({ onMoveShouldSetResponderCapture: null })\n    }\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: { registrationName: keyOf({ onResponderStart: null }) },\n  responderMove: { registrationName: keyOf({ onResponderMove: null }) },\n  responderEnd: { registrationName: keyOf({ onResponderEnd: null }) },\n  responderRelease: { registrationName: keyOf({ onResponderRelease: null }) },\n  responderTerminationRequest: {\n    registrationName: keyOf({ onResponderTerminationRequest: null })\n  },\n  responderGrant: { registrationName: keyOf({ onResponderGrant: null }) },\n  responderReject: { registrationName: keyOf({ onResponderReject: null }) },\n  responderTerminate: { registrationName: keyOf({ onResponderTerminate: null }) }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occuring, the responder lock can be transfered to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderID`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendents of the\n *   *current* responderID, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n *\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {string} topLevelTargetID ID of deepest React rendered element.\n * @param {object} nativeEvent Native browser event.\n * @return {*} An accumulation of synthetic events.\n */\nfunction setResponderAndExtractTransfer(topLevelType, topLevelTargetID, nativeEvent, nativeEventTarget) {\n  var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === EventConstants.topLevelTypes.topSelectionChange ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;\n\n  // TODO: stop one short of the the current responder.\n  var bubbleShouldSetFrom = !responderID ? topLevelTargetID : ReactInstanceHandles.getFirstCommonAncestorID(responderID, topLevelTargetID);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderID;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    EventPropagators.accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    EventPropagators.accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderID = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderID || wantsResponderID === responderID) {\n    return null;\n  }\n  var extracted;\n  var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderID, nativeEvent, nativeEventTarget);\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  EventPropagators.accumulateDirectDispatches(grantEvent);\n  var blockNativeResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderID) {\n\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderID, nativeEvent, nativeEventTarget);\n    terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n    EventPropagators.accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateType = eventTypes.responderTerminate;\n      var terminateEvent = ResponderSyntheticEvent.getPooled(terminateType, responderID, nativeEvent, nativeEventTarget);\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      EventPropagators.accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderID, blockNativeResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderID, nativeEvent, nativeEventTarget);\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      EventPropagators.accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderID, blockNativeResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderID. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `EventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelTargetID, nativeEvent) {\n  return topLevelTargetID && (\n  // responderIgnoreScroll: We are trying to migrate away from specifically tracking native scroll\n  // events here and responderIgnoreScroll indicates we will send topTouchCancel to handle\n  // canceling touch events instead\n  topLevelType === EventConstants.topLevelTypes.topScroll && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === EventConstants.topLevelTypes.topSelectionChange || isStartish(topLevelType) || isMoveish(topLevelType));\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderID`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var isAncestor = ReactInstanceHandles.isAncestorIDOf(responderID, EventPluginUtils.getID(target));\n      if (isAncestor) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n\n  getResponderID: function () {\n    return responderID;\n  },\n\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `topLevelTargetID` being `undefined` on\n   * `touchMove`, or `touchEnd`. On certain platforms, this means that a native\n   * scroll has assumed control and the original touch targets are destroyed.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      trackedTouchCount -= 1;\n      !(trackedTouchCount >= 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Ended a touch event which was not counted in trackedTouchCount.') : invariant(false) : undefined;\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent, nativeEventTarget);\n\n    var extracted = canTriggerTransfer(topLevelType, topLevelTargetID, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, topLevelTargetID, nativeEvent, nativeEventTarget) : null;\n    // Responder may or may not have transfered on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderID && isStartish(topLevelType);\n    var isResponderTouchMove = responderID && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderID && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderID, nativeEvent, nativeEventTarget);\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      EventPropagators.accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate = responderID && topLevelType === EventConstants.topLevelTypes.topTouchCancel;\n    var isResponderRelease = responderID && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderID, nativeEvent, nativeEventTarget);\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      EventPropagators.accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    var numberActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;\n    if (ResponderEventPlugin.GlobalInteractionHandler && numberActiveTouches !== previousActiveTouches) {\n      ResponderEventPlugin.GlobalInteractionHandler.onChange(numberActiveTouches);\n    }\n    previousActiveTouches = numberActiveTouches;\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n  GlobalInteractionHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function (GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    },\n\n    /**\n     * @param {{onChange: (numberActiveTouches) => void} GlobalInteractionHandler\n     * Object that handles any change in the number of active touches.\n     */\n    injectGlobalInteractionHandler: function (GlobalInteractionHandler) {\n      ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;\n    }\n  }\n};\n\nmodule.exports = ResponderEventPlugin;"]}