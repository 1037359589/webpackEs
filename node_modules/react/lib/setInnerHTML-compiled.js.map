{"version":3,"sources":["setInnerHTML.js"],"names":[],"mappings":";;;;;;;;;;;;;AAaA,YAAY,CAAC;;AAEb,IAAI,oBAAoB,GAAG,OAAO,CAAC,+BAA+B,CAAC,CAAC;;AAEpE,IAAI,eAAe,GAAG,cAAc,CAAC;AACrC,IAAI,eAAe,GAAG,sDAAsD;;;;;;;;;;AAAC,AAU7E,IAAI,YAAY,GAAG,UAAU,IAAI,EAAE,IAAI,EAAE;AACvC,MAAI,CAAC,SAAS,GAAG,IAAI,CAAC;CACvB;;;AAAC,AAGF,IAAI,OAAO,KAAK,KAAK,WAAW,IAAI,KAAK,CAAC,uBAAuB,EAAE;AACjE,cAAY,GAAG,UAAU,IAAI,EAAE,IAAI,EAAE;AACnC,SAAK,CAAC,uBAAuB,CAAC,YAAY;AACxC,UAAI,CAAC,SAAS,GAAG,IAAI,CAAC;KACvB,CAAC,CAAC;GACJ,CAAC;CACH;;AAED,IAAI,oBAAoB,CAAC,SAAS,EAAE;;;;;;;AAOlC,MAAI,WAAW,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;AAChD,aAAW,CAAC,SAAS,GAAG,GAAG,CAAC;AAC5B,MAAI,WAAW,CAAC,SAAS,KAAK,EAAE,EAAE;AAChC,gBAAY,GAAG,UAAU,IAAI,EAAE,IAAI,EAAE;;;;;;AAMnC,UAAI,IAAI,CAAC,UAAU,EAAE;AACnB,YAAI,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;OAC1C;;;;;;AAAA,AAMD,UAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;;;;;;;AAO/E,YAAI,CAAC,SAAS,GAAG,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,IAAI;;;;AAAC,AAIpD,YAAI,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC;AAC/B,YAAI,QAAQ,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;AAC9B,cAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;SAC5B,MAAM;AACL,kBAAQ,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SAC3B;OACF,MAAM;AACL,YAAI,CAAC,SAAS,GAAG,IAAI,CAAC;OACvB;KACF,CAAC;GACH;CACF;;AAED,MAAM,CAAC,OAAO,GAAG,YAAY,CAAC","file":"setInnerHTML-compiled.js","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule setInnerHTML\n */\n\n/* globals MSApp */\n\n'use strict';\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar WHITESPACE_TEST = /^[ \\r\\n\\t\\f]/;\nvar NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \\r\\n\\t\\f\\/>]/;\n\n/**\n * Set the innerHTML property of a node, ensuring that whitespace is preserved\n * even in IE8.\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = function (node, html) {\n  node.innerHTML = html;\n};\n\n// Win8 apps: Allow all html to be inserted\nif (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n  setInnerHTML = function (node, html) {\n    MSApp.execUnsafeLocalFunction(function () {\n      node.innerHTML = html;\n    });\n  };\n}\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8: When updating a just created node with innerHTML only leading\n  // whitespace is removed. When updating an existing node with innerHTML\n  // whitespace in root TextNodes is also collapsed.\n  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html\n\n  // Feature detection; only IE8 is known to behave improperly like this.\n  var testElement = document.createElement('div');\n  testElement.innerHTML = ' ';\n  if (testElement.innerHTML === '') {\n    setInnerHTML = function (node, html) {\n      // Magic theory: IE8 supposedly differentiates between added and updated\n      // nodes when processing innerHTML, innerHTML on updated nodes suffers\n      // from worse whitespace behavior. Re-adding a node like this triggers\n      // the initial and more favorable whitespace behavior.\n      // TODO: What to do on a detached node?\n      if (node.parentNode) {\n        node.parentNode.replaceChild(node, node);\n      }\n\n      // We also implement a workaround for non-visible tags disappearing into\n      // thin air on IE8, this only happens if there is no visible text\n      // in-front of the non-visible tags. Piggyback on the whitespace fix\n      // and simply check if any non-visible tags appear in the source.\n      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {\n        // Recover leading whitespace by temporarily prepending any character.\n        // \\uFEFF has the potential advantage of being zero-width/invisible.\n        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode\n        // in hopes that this is preserved even if \"\\uFEFF\" is transformed to\n        // the actual Unicode character (by Babel, for example).\n        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216\n        node.innerHTML = String.fromCharCode(0xFEFF) + html;\n\n        // deleteData leaves an empty `TextNode` which offsets the index of all\n        // children. Definitely want to avoid this.\n        var textNode = node.firstChild;\n        if (textNode.data.length === 1) {\n          node.removeChild(textNode);\n        } else {\n          textNode.deleteData(0, 1);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    };\n  }\n}\n\nmodule.exports = setInnerHTML;"]}