{"version":3,"sources":["utils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAkBA,IAAI,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC;AAC1C,IAAI,mBAAmB,GAAG,kBAAkB,CAAC;AAC7C,IAAI,cAAc,GAAG,OAAO;;;;;;;;;;;;;AAAC,AAa7B,SAAS,WAAW,CAAC,MAAM,EAAE,QAAQ,EAAE,gBAAgB,EAAE;AACvD,SAAO;;;;;;AAML,cAAU,EAAE;AACV,gBAAU,EAAE,QAAQ;AACpB,iBAAW,EAAE,IAAI;AACjB,iBAAW,EAAE,EAAE;AACf,kBAAY,EAAE,CAAC;AACf,cAAQ,EAAE,EAAE;KACb;;;;;AAKD,cAAU,EAAE,IAAI;;;;;AAKhB,kBAAc,EAAE,EAAE;;;;;AAKlB,cAAU,EAAE,IAAI;;;;;;AAMhB,kBAAc,EAAE,IAAI;;;;;AAKpB,aAAS,EAAE,IAAI;;;;;AAKf,iBAAa,EAAE,IAAI;;;;;AAKnB,YAAQ,EAAE,CAAC;;;;;AAKX,KAAC,EAAE;;;;;;;;;;;;;;AAcD,UAAI,EAAE,gBAAgB;;;;;AAKtB,cAAQ,EAAE,CAAC;;;;;AAKX,WAAK,EAAE,EAAE;;;;;AAKT,YAAM,EAAE,EAAE;;;;;AAKV,YAAM,EAAE,MAAM;;;;;;AAMd,cAAQ,EAAE,IAAI;;;;;;AAMd,sBAAgB,EAAE,KAAK;;;;;;AAMvB,YAAM,EAAE,SAAS;;;;;;AAMjB,eAAS,EAAE,IAAI;;;;;;AAMf,uBAAiB,EAAE,WAAW;;;;;;;AAO9B,gBAAU,EAAE,CAAC;;;;;;;AAOb,gBAAU,EAAE,CAAC;;;;;AAKb,wBAAkB,EAAE,IAAI;;AAExB,kBAAY,EAAE,CAAC;AACf,kBAAY,EAAE,CAAC;KAChB;GACF,CAAC;CACH;;;;;;;;;AAAA,AASD,SAAS,WAAW,CAAC,KAAK,EAAE,MAAM,EAAE;AAClC,MAAI,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC/B,QAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,UAAS,UAAU,EAAE;AAC/C,OAAG,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC;GACtC,CAAC,CAAC;AACH,SAAO,GAAG,CAAC;CACZ;;;;;;;;;;;AAAA,AAWD,SAAS,OAAO,CAAC,GAAG,EAAE,KAAK,EAAE,kBAAkB,EAAE;AAC/C,MAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE;;AAE1B,WAAO;GACR;AACD,MAAI,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;AAC7D,MAAI,WAAW,GAAG,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AAC9C,MAAI,KAAK,CAAC,CAAC,CAAC,SAAS,IAAI,WAAW,EAAE;;AAEpC,SAAK,CAAC,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC;AAC3B,eAAS,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,YAAY,EAAE;AACrE,cAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,YAAY,EAAE;AACpE,YAAM,EAAE,KAAK,CAAC,CAAC,CAAC,iBAAiB;KAClC,CAAC;;;AAAC,AAGH,QAAI,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACrC,QAAI,gBAAgB,GAAG,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC;;;;;;;;AAAC,AAQ/C,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;AAC/C,WAAK,CAAC,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC;AAC3B,iBAAS,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC,EAAE;AAClD,gBAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC,EAAE;AACjD,cAAM,EAAE,KAAK,CAAC,CAAC,CAAC,iBAAiB;OAClC,CAAC,CAAC;AACH,WAAK,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;AACrB,WAAK,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;KACtB;;AAAA,AAED,QAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,WAAK,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;AACrB,WAAK,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;AACrB,WAAK,CAAC,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC;AACzB,WAAK,CAAC,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC;KAC1B;AACD,SAAK,CAAC,CAAC,CAAC,YAAY,IAAI,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;AACnE,SAAK,CAAC,CAAC,CAAC,YAAY,IAClB,gBAAgB,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;GACxD;AACD,OAAK,CAAC,CAAC,CAAC,MAAM,IACZ,kBAAkB,GAAG,kBAAkB,CAAC,WAAW,CAAC,GAAG,WAAW,CAAC;AACrE,OAAK,CAAC,CAAC,CAAC,QAAQ,GAAG,GAAG,CAAC;CACxB;;;;;;;;AAAA,AAQD,SAAS,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE;AACtC,SAAO,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;CAC/D;;AAED,SAAS,gBAAgB,CAAC,KAAK,EAAE;AAC/B,SAAO,KAAK,CAAC,OAAO,CAAC,cAAc,EAAE,GAAG,CAAC,CAAC;CAC3C;;;;;AAAA,AAKD,SAAS,cAAc,CAAC,KAAK,EAAE;AAC7B,SAAO,KAAK,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;CAC1C;;;;;;;;;;;;;;AAAA,AAcD,SAAS,0BAA0B,CAAC,IAAI,EAAE,KAAK,EAAE;AAC/C,MAAI,aAAa,GAAG,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;AAC/D,MAAI,kBAAkB,GAAG,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;;AAEnD,MAAI,UAAU,GAAG,CAAC,CAAC;AACnB,MAAI,IAAI,CAAC;AACT,MAAI,kBAAkB,GAAG,KAAK,CAAC;AAC/B,MAAI,YAAY,GAAG,KAAK,CAAC;AACzB,UAAQ,EAAE,OAAO,CAAC,IAAI,GAAG,kBAAkB,CAAC,KAAK,EAAE,CAAA,KAAM,SAAS,EAAE;AAClE,QAAI,UAAU,GAAG,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC;AAC1C,YAAQ,EAAE,OAAO,UAAU,GAAG,UAAU,EAAE,UAAU,EAAE,EAAE;AACtD,UAAI,QAAQ,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC;AACzC,UAAI,QAAQ,KAAK,GAAG,IAAI,QAAQ,KAAK,IAAI,EAAE;AACzC,oBAAY,GAAG,CAAC,YAAY,CAAC;AAC7B,iBAAS,QAAQ,CAAC;OACnB,MAAM,IAAI,YAAY,EAAE;AACvB,iBAAS,QAAQ,CAAC;OACnB,MAAM,IAAI,UAAU,GAAG,CAAC,GAAG,UAAU,EAAE;AACtC,YAAI,YAAY,GAAG,QAAQ,GAAG,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;AACnD,YAAI,YAAY,KAAK,IAAI,EAAE;AACzB,oBAAU,GAAG,UAAU,GAAG,CAAC,CAAC;AAC5B,mBAAS,QAAQ,CAAC;SACnB,MAAM,IAAI,YAAY,KAAK,IAAI,EAAE;AAChC,4BAAkB,GAAG,IAAI,CAAC;AAC1B,oBAAU,IAAI,CAAC,CAAC;AAChB,mBAAS,QAAQ,CAAC;SACnB,MAAM,IAAI,YAAY,KAAK,IAAI,EAAE;AAChC,4BAAkB,GAAG,KAAK,CAAC;AAC3B,oBAAU,IAAI,CAAC,CAAC;AAChB,mBAAS,QAAQ,CAAC;SACnB;OACF;;AAED,UAAI,CAAC,kBAAkB,IAAI,QAAQ,KAAK,IAAI,EAAE;AAC5C,eAAO,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC;OACtC;KACF;;;AAAA,AAGD,cAAU,EAAE,CAAC;AACb,gBAAY,GAAG,KAAK,CAAC;GACtB;;AAED,QAAM,IAAI,KAAK,CAAC,GAAG,GAAG,IAAI,GAAG,cAAc,CAAC,CAAC;CAC9C;;;;;AAAA,AAKD,SAAS,eAAe,CAAC,GAAG,EAAE,KAAK,EAAE;AACnC,SAAO,CAAC,GAAG,EAAE,KAAK,EAAE,gBAAgB,CAAC,CAAC;CACvC;;;;;AAAA,AAKD,SAAS,iBAAiB,CAAC,GAAG,EAAE,KAAK,EAAE;AACrC,SAAO,CAAC,GAAG,EAAE,KAAK,EAAE,cAAc,CAAC,CAAC;CACrC;;;;;AAAA,AAKD,IAAI,YAAY,GAAG,QAAQ,CAAC;AAC5B,SAAS,eAAe,CAAC,KAAK,EAAE;AAC9B,SAAO,KAAK,CAAC,OAAO,CAAC,YAAY,EAAE,YAAW;AAC5C,WAAO,EAAE,CAAC;GACX,CAAC,CAAC;CACJ;;;;;;;;AAAA,AAQD,SAAS,eAAe,CAAC,GAAG,EAAE,KAAK,EAAE;AACnC,SAAO,CAAC,GAAG,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC;CACtC;;;;;;;;AAAA,AASD,SAAS,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE;;AAExB,MAAI,KAAK,CAAC,CAAC,CAAC,SAAS,EAAE;AACrB,QAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE;AAC1B,WAAK,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC;AACrB,WAAK,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC;AACvB,WAAK,CAAC,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC;KAC1B;;AAED,QAAI,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;AAC7D,QAAI,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACrC,QAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,WAAK,CAAC,CAAC,CAAC,UAAU,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;AAC7C,WAAK,CAAC,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC;KAC1B;AACD,SAAK,CAAC,CAAC,CAAC,YAAY,IAAI,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;GACpE;AACD,OAAK,CAAC,CAAC,CAAC,QAAQ,GAAG,GAAG,CAAC;CACxB;;;;;;;;AAAA,AAQD,SAAS,MAAM,CAAC,GAAG,EAAE,KAAK,EAAE;AAC1B,MAAI,KAAK,CAAC,CAAC,CAAC,SAAS,IAAI,GAAG,EAAE;AAC5B,SAAK,CAAC,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC;AAC3B,eAAS,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,YAAY,EAAE;AACrE,cAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,YAAY,EAAE;AACpE,YAAM,EAAE,KAAK,CAAC,CAAC,CAAC,iBAAiB;KAClC,CAAC,CAAC;AACH,QAAI,gBAAgB,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACvC,QAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE;AAC/B,WAAK,CAAC,CAAC,CAAC,UAAU,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC;AAClD,WAAK,CAAC,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC;KAC1B;AACD,SAAK,CAAC,CAAC,CAAC,YAAY,IAClB,gBAAgB,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;GACxD;AACD,OAAK,CAAC,CAAC,CAAC,MAAM,IAAI,GAAG,CAAC;CACvB;;;;;;;;;;AAAA,AAUD,SAAS,YAAY,CAAC,GAAG,EAAE,KAAK,EAAE;;AAEhC,MAAI,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;AAC9B,MAAI,QAAQ,GAAG,CAAC,EAAE;AAChB,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,EAAE,EAAE;AAClC,SAAG,GAAG,GAAG,CAAC,OAAO,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAAC;KAC9C;GACF,MAAM;AACL,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AACjC,SAAG,GAAG,GAAG,CAAC,OAAO,CAAC,mBAAmB,EAAE,QAAQ,CAAC,CAAC;KAClD;GACF;AACD,SAAO,GAAG,CAAC;CACZ;;;;;;;;;;;;;;;AAAA,AAeD,SAAS,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE;AAClC,MAAI,GAAG,GAAG,KAAK,CAAC;AAChB,OAAK,GAAG,KAAK,GAAG,CAAC,CAAC;;AAElB,SAAO,KAAK,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,IAAI,EAAE;AACjD,QAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;AACzC,SAAG,GAAG,KAAK,CAAC;KACb;AACD,SAAK,EAAE,CAAC;GACT;AACD,SAAO,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;CACjD;;AAED,SAAS,WAAW,CAAC,KAAK,EAAE;AAC1B,MAAI,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE;AACrB,QAAI,QAAQ,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AACrC,SAAK,CAAC,CAAC,CAAC,QAAQ,GACd,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;GAC5D;AACD,SAAO,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC;CACzB;;AAED,SAAS,uBAAuB,CAAC,SAAS,EAAE,KAAK,EAAE,cAAc,EAAE;AACjE,MAAI,SAAS,GAAG,KAAK,CAAC,UAAU,CAAC;AACjC,SAAO,SAAS,EAAE;AAChB,QAAI,SAAS,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,SAAS,EAAE;AAClD,aAAO,IAAI,CAAC;KACb;;AAED,QAAI,cAAc,IAAI,SAAS,CAAC,UAAU,KAAK,cAAc,EAAE;AAC7D,YAAM;KACP;;AAED,aAAS,GAAG,SAAS,CAAC,WAAW,CAAC;GACnC;AACD,SAAO,KAAK,CAAC;CACd;;AAED,SAAS,iBAAiB,CAAC,SAAS,EAAE,KAAK,EAAE;AAC3C,SAAO,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC;CAC9D;;;;;;;AAAA,AAOD,SAAS,iBAAiB,CAAC,YAAY,EAAE,IAAI,EAAE,IAAI,EAAE;AACnD,SAAO;AACL,gBAAY,EAAE,YAAY;AAC1B,eAAW,EAAE,IAAI;AACjB,eAAW,EAAE,IAAI;GAClB,CAAC;CACH;;AAED,SAAS,wBAAwB,CAAC,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE;AAC5D,OAAK,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG;AACxC,gBAAY,EAAE,QAAQ,CAAC,YAAY;AACnC,QAAI,EAAE,QAAQ,CAAC,WAAW;AAC1B,QAAI,EAAE,QAAQ,CAAC,WAAW;AAC1B,SAAK,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC;GAC5B,CAAC;CACH;;AAED,SAAS,yBAAyB,CAAC,SAAS,EAAE,KAAK,EAAE;AACnD,MAAI,SAAS,GAAG,KAAK,CAAC,UAAU,CAAC;AACjC,SAAO,SAAS,EAAE;AAChB,QAAI,SAAS,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,SAAS,EAAE;AAClD,aAAO,SAAS,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;KACzC;;AAED,aAAS,GAAG,SAAS,CAAC,WAAW,CAAC;GACnC;CACF;;AAED,SAAS,uBAAuB,CAAC,SAAS,EAAE,KAAK,EAAE;AACjD,SAAO,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;CAChD;;;;;;;;;;;;;AAAA,AAaD,SAAS,kBAAkB,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE;AAClE,MAAI,IAAI,CAAC,IAAI,EAAE;AACb,QAAI,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,KAAK,KAAK,EAAE;AACzC,aAAO;KACR;AACD,QAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;GACpB;;AAED,oBAAkB,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,UAAS,KAAK,EAAE;AAC/C,aAAS,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;GAC/B,CAAC,CAAC;;AAEH,MAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;CAC3B;;;;;;;;;;;;;;;;;AAAA,AAiBD,SAAS,kBAAkB,CAAC,IAAI,EAAE;AAChC,MAAI,KAAK,GAAG,EAAE,CAAC;AACf,OAAK,IAAI,GAAG,IAAI,IAAI,EAAE;AACpB,QAAI,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;AAC5B,+BAAyB,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;KAC7C;GACF;AACD,OAAK,CAAC,IAAI,CAAC,UAAS,CAAC,EAAE,CAAC,EAAE;AAAE,WAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;GAAE,CAAC,CAAC;AACnD,SAAO,KAAK,CAAC,GAAG,CAAC,UAAS,IAAI,EAAE;AAAE,WAAO,IAAI,CAAC,CAAC,CAAC,CAAC;GAAE,CAAC,CAAC;CACtD;;;;;;;;;;;;;;AAAA,AAcD,SAAS,yBAAyB,CAAC,KAAK,EAAE,IAAI,EAAE;AAC9C,MAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,KAAK,IAAI,EAAE;AAC7C,WAAO;GACR;AACD,MAAI,IAAI,CAAC,KAAK,EAAE;AACd,SAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;GACnC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AAC9B,SAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE;AACvC,+BAAyB,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;KAC5C;GACF;CACF;;;;;;;;AAAA,AAQD,SAAS,mBAAmB,CAAC,IAAI,EAAE,IAAI,EAAE;AACvC,SAAO,qBAAqB,CAAC,IAAI,EAAE,UAAS,IAAI,EAAE;AAChD,WAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;GAC3B,CAAC,CAAC;CACJ;;AAED,SAAS,qBAAqB,CAAC,IAAI,EAAE,OAAO,EAAE;AAC5C,MAAI,kBAAkB,GAAG,KAAK,CAAC;AAC/B,WAAS,gBAAgB,CAAC,IAAI,EAAE;AAC9B,QAAI,OAAO,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE;AAC1B,wBAAkB,GAAG,IAAI,CAAC;AAC1B,aAAO,KAAK,CAAC;KACd;GACF;AACD,WAAS,iBAAiB,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;AAC7C,QAAI,CAAC,kBAAkB,EAAE;AACvB,wBAAkB,GAAG,qBAAqB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KAC5D;GACF;AACD,oBAAkB,CAChB,gBAAgB,EAChB,iBAAiB,EACjB,IAAI,EACJ,EAAE,CACH,CAAC;AACF,SAAO,kBAAkB,CAAC;CAC3B;;AAED,IAAI,UAAU,GAAG,EAAE,CAAC;AACpB,UAAU,CAAC,MAAM,CAAC,uBAAuB,CAAC,GAAG,IAAI,CAAC;AAClD,UAAU,CAAC,MAAM,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC;AAC7C,UAAU,CAAC,MAAM,CAAC,mBAAmB,CAAC,GAAG,IAAI,CAAC;AAC9C,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC;;AAElC,SAAS,eAAe,CAAC,IAAI,EAAE;AAC7B,OAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE;AACvC,QAAI,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE;AAC7B,aAAO,IAAI,CAAC,EAAE,CAAC,CAAC;KACjB;GACF;AACD,QAAM,IAAI,KAAK,CACb,oEAAoE,GACpE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CACxC,CAAC;CACH;;AAED,SAAS,UAAU,CAAC,YAAY,EAAE;AAChC,SAAO,KAAK,GAAG,YAAY,CAAC;CAC7B;;AAED,SAAS,aAAa,CAAC,KAAK,EAAE;AAC5B,MAAI,OAAO,GAAG,KAAK,GAAI,KAAK,CAAC,UAAU,CAAC,YAAY,EAAE,AAAC,CAAC;AACxD,OAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACxC,SAAO,OAAO,CAAC;CAChB;;AAED,SAAS,yBAAyB,CAAC,KAAK,EAAE,KAAK,EAAE;AAC/C,MAAI,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,MAAM,EAAE;AACpC,SAAK,CAAC,CAAC,CAAC,MAAM,GACZ,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,GAC9B,MAAM,GAAG,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GACnD,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAC9B,SAAK,CAAC,UAAU,CAAC,QAAQ,GAAG,EAAE,CAAC;GAChC;CACF;;AAED,OAAO,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;AAChD,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC;AACxB,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC;AAC1B,OAAO,CAAC,eAAe,GAAG,eAAe,CAAC;AAC1C,OAAO,CAAC,eAAe,GAAG,eAAe,CAAC;AAC1C,OAAO,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;AAC9C,OAAO,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;AACtD,OAAO,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;AAClD,OAAO,CAAC,WAAW,GAAG,WAAW,CAAC;AAClC,OAAO,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;AAC5D,OAAO,CAAC,eAAe,GAAG,eAAe,CAAC;AAC1C,OAAO,CAAC,WAAW,GAAG,WAAW,CAAC;AAClC,OAAO,CAAC,yBAAyB,GAAG,yBAAyB,CAAC;AAC9D,OAAO,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;AAC1D,OAAO,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;AAChE,OAAO,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;AAC9C,OAAO,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;AAChD,OAAO,CAAC,UAAU,GAAG,UAAU,CAAC;AAChC,OAAO,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;AAC9C,OAAO,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;AAC1D,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC;AACpC,OAAO,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;AAC9C,OAAO,CAAC,aAAa,GAAG,aAAa,CAAC;AACtC,OAAO,CAAC,yBAAyB,GAAG,yBAAyB,CAAC;AAC9D,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC;AACpB,OAAO,CAAC,UAAU,GAAG,UAAU,CAAC;AAChC,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC;AACpC,OAAO,CAAC,WAAW,GAAG,WAAW,CAAC","file":"utils-compiled.js","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/*jslint node: true*/\nvar Syntax = require('esprima-fb').Syntax;\nvar leadingIndentRegexp = /(^|\\n)( {2}|\\t)/g;\nvar nonWhiteRegexp = /(\\S)/g;\n\n/**\n * A `state` object represents the state of the parser. It has \"local\" and\n * \"global\" parts. Global contains parser position, source, etc. Local contains\n * scope based properties like current class name. State should contain all the\n * info required for transformation. It's the only mandatory object that is\n * being passed to every function in transform chain.\n *\n * @param  {string} source\n * @param  {object} transformOptions\n * @return {object}\n */\nfunction createState(source, rootNode, transformOptions) {\n  return {\n    /**\n     * A tree representing the current local scope (and its lexical scope chain)\n     * Useful for tracking identifiers from parent scopes, etc.\n     * @type {Object}\n     */\n    localScope: {\n      parentNode: rootNode,\n      parentScope: null,\n      identifiers: {},\n      tempVarIndex: 0,\n      tempVars: []\n    },\n    /**\n     * The name (and, if applicable, expression) of the super class\n     * @type {Object}\n     */\n    superClass: null,\n    /**\n     * The namespace to use when munging identifiers\n     * @type {String}\n     */\n    mungeNamespace: '',\n    /**\n     * Ref to the node for the current MethodDefinition\n     * @type {Object}\n     */\n    methodNode: null,\n    /**\n     * Ref to the node for the FunctionExpression of the enclosing\n     * MethodDefinition\n     * @type {Object}\n     */\n    methodFuncNode: null,\n    /**\n     * Name of the enclosing class\n     * @type {String}\n     */\n    className: null,\n    /**\n     * Whether we're currently within a `strict` scope\n     * @type {Bool}\n     */\n    scopeIsStrict: null,\n    /**\n     * Indentation offset\n     * @type {Number}\n     */\n    indentBy: 0,\n    /**\n     * Global state (not affected by updateState)\n     * @type {Object}\n     */\n    g: {\n      /**\n       * A set of general options that transformations can consider while doing\n       * a transformation:\n       *\n       * - minify\n       *   Specifies that transformation steps should do their best to minify\n       *   the output source when possible. This is useful for places where\n       *   minification optimizations are possible with higher-level context\n       *   info than what jsxmin can provide.\n       *\n       *   For example, the ES6 class transform will minify munged private\n       *   variables if this flag is set.\n       */\n      opts: transformOptions,\n      /**\n       * Current position in the source code\n       * @type {Number}\n       */\n      position: 0,\n      /**\n       * Auxiliary data to be returned by transforms\n       * @type {Object}\n       */\n      extra: {},\n      /**\n       * Buffer containing the result\n       * @type {String}\n       */\n      buffer: '',\n      /**\n       * Source that is being transformed\n       * @type {String}\n       */\n      source: source,\n\n      /**\n       * Cached parsed docblock (see getDocblock)\n       * @type {object}\n       */\n      docblock: null,\n\n      /**\n       * Whether the thing was used\n       * @type {Boolean}\n       */\n      tagNamespaceUsed: false,\n\n      /**\n       * If using bolt xjs transformation\n       * @type {Boolean}\n       */\n      isBolt: undefined,\n\n      /**\n       * Whether to record source map (expensive) or not\n       * @type {SourceMapGenerator|null}\n       */\n      sourceMap: null,\n\n      /**\n       * Filename of the file being processed. Will be returned as a source\n       * attribute in the source map\n       */\n      sourceMapFilename: 'source.js',\n\n      /**\n       * Only when source map is used: last line in the source for which\n       * source map was generated\n       * @type {Number}\n       */\n      sourceLine: 1,\n\n      /**\n       * Only when source map is used: last line in the buffer for which\n       * source map was generated\n       * @type {Number}\n       */\n      bufferLine: 1,\n\n      /**\n       * The top-level Program AST for the original file.\n       */\n      originalProgramAST: null,\n\n      sourceColumn: 0,\n      bufferColumn: 0\n    }\n  };\n}\n\n/**\n * Updates a copy of a given state with \"update\" and returns an updated state.\n *\n * @param  {object} state\n * @param  {object} update\n * @return {object}\n */\nfunction updateState(state, update) {\n  var ret = Object.create(state);\n  Object.keys(update).forEach(function(updatedKey) {\n    ret[updatedKey] = update[updatedKey];\n  });\n  return ret;\n}\n\n/**\n * Given a state fill the resulting buffer from the original source up to\n * the end\n *\n * @param {number} end\n * @param {object} state\n * @param {?function} contentTransformer Optional callback to transform newly\n *                                       added content.\n */\nfunction catchup(end, state, contentTransformer) {\n  if (end < state.g.position) {\n    // cannot move backwards\n    return;\n  }\n  var source = state.g.source.substring(state.g.position, end);\n  var transformed = updateIndent(source, state);\n  if (state.g.sourceMap && transformed) {\n    // record where we are\n    state.g.sourceMap.addMapping({\n      generated: { line: state.g.bufferLine, column: state.g.bufferColumn },\n      original: { line: state.g.sourceLine, column: state.g.sourceColumn },\n      source: state.g.sourceMapFilename\n    });\n\n    // record line breaks in transformed source\n    var sourceLines = source.split('\\n');\n    var transformedLines = transformed.split('\\n');\n    // Add line break mappings between last known mapping and the end of the\n    // added piece. So for the code piece\n    //  (foo, bar);\n    // > var x = 2;\n    // > var b = 3;\n    //   var c =\n    // only add lines marked with \">\": 2, 3.\n    for (var i = 1; i < sourceLines.length - 1; i++) {\n      state.g.sourceMap.addMapping({\n        generated: { line: state.g.bufferLine, column: 0 },\n        original: { line: state.g.sourceLine, column: 0 },\n        source: state.g.sourceMapFilename\n      });\n      state.g.sourceLine++;\n      state.g.bufferLine++;\n    }\n    // offset for the last piece\n    if (sourceLines.length > 1) {\n      state.g.sourceLine++;\n      state.g.bufferLine++;\n      state.g.sourceColumn = 0;\n      state.g.bufferColumn = 0;\n    }\n    state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;\n    state.g.bufferColumn +=\n      transformedLines[transformedLines.length - 1].length;\n  }\n  state.g.buffer +=\n    contentTransformer ? contentTransformer(transformed) : transformed;\n  state.g.position = end;\n}\n\n/**\n * Returns original source for an AST node.\n * @param {object} node\n * @param {object} state\n * @return {string}\n */\nfunction getNodeSourceText(node, state) {\n  return state.g.source.substring(node.range[0], node.range[1]);\n}\n\nfunction _replaceNonWhite(value) {\n  return value.replace(nonWhiteRegexp, ' ');\n}\n\n/**\n * Removes all non-whitespace characters\n */\nfunction _stripNonWhite(value) {\n  return value.replace(nonWhiteRegexp, '');\n}\n\n/**\n * Finds the position of the next instance of the specified syntactic char in\n * the pending source.\n *\n * NOTE: This will skip instances of the specified char if they sit inside a\n *       comment body.\n *\n * NOTE: This function also assumes that the buffer's current position is not\n *       already within a comment or a string. This is rarely the case since all\n *       of the buffer-advancement utility methods tend to be used on syntactic\n *       nodes' range values -- but it's a small gotcha that's worth mentioning.\n */\nfunction getNextSyntacticCharOffset(char, state) {\n  var pendingSource = state.g.source.substring(state.g.position);\n  var pendingSourceLines = pendingSource.split('\\n');\n\n  var charOffset = 0;\n  var line;\n  var withinBlockComment = false;\n  var withinString = false;\n  lineLoop: while ((line = pendingSourceLines.shift()) !== undefined) {\n    var lineEndPos = charOffset + line.length;\n    charLoop: for (; charOffset < lineEndPos; charOffset++) {\n      var currChar = pendingSource[charOffset];\n      if (currChar === '\"' || currChar === '\\'') {\n        withinString = !withinString;\n        continue charLoop;\n      } else if (withinString) {\n        continue charLoop;\n      } else if (charOffset + 1 < lineEndPos) {\n        var nextTwoChars = currChar + line[charOffset + 1];\n        if (nextTwoChars === '//') {\n          charOffset = lineEndPos + 1;\n          continue lineLoop;\n        } else if (nextTwoChars === '/*') {\n          withinBlockComment = true;\n          charOffset += 1;\n          continue charLoop;\n        } else if (nextTwoChars === '*/') {\n          withinBlockComment = false;\n          charOffset += 1;\n          continue charLoop;\n        }\n      }\n\n      if (!withinBlockComment && currChar === char) {\n        return charOffset + state.g.position;\n      }\n    }\n\n    // Account for '\\n'\n    charOffset++;\n    withinString = false;\n  }\n\n  throw new Error('`' + char + '` not found!');\n}\n\n/**\n * Catches up as `catchup` but replaces non-whitespace chars with spaces.\n */\nfunction catchupWhiteOut(end, state) {\n  catchup(end, state, _replaceNonWhite);\n}\n\n/**\n * Catches up as `catchup` but removes all non-whitespace characters.\n */\nfunction catchupWhiteSpace(end, state) {\n  catchup(end, state, _stripNonWhite);\n}\n\n/**\n * Removes all non-newline characters\n */\nvar reNonNewline = /[^\\n]/g;\nfunction stripNonNewline(value) {\n  return value.replace(reNonNewline, function() {\n    return '';\n  });\n}\n\n/**\n * Catches up as `catchup` but removes all non-newline characters.\n *\n * Equivalent to appending as many newlines as there are in the original source\n * between the current position and `end`.\n */\nfunction catchupNewlines(end, state) {\n  catchup(end, state, stripNonNewline);\n}\n\n\n/**\n * Same as catchup but does not touch the buffer\n *\n * @param  {number} end\n * @param  {object} state\n */\nfunction move(end, state) {\n  // move the internal cursors\n  if (state.g.sourceMap) {\n    if (end < state.g.position) {\n      state.g.position = 0;\n      state.g.sourceLine = 1;\n      state.g.sourceColumn = 0;\n    }\n\n    var source = state.g.source.substring(state.g.position, end);\n    var sourceLines = source.split('\\n');\n    if (sourceLines.length > 1) {\n      state.g.sourceLine += sourceLines.length - 1;\n      state.g.sourceColumn = 0;\n    }\n    state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;\n  }\n  state.g.position = end;\n}\n\n/**\n * Appends a string of text to the buffer\n *\n * @param {string} str\n * @param {object} state\n */\nfunction append(str, state) {\n  if (state.g.sourceMap && str) {\n    state.g.sourceMap.addMapping({\n      generated: { line: state.g.bufferLine, column: state.g.bufferColumn },\n      original: { line: state.g.sourceLine, column: state.g.sourceColumn },\n      source: state.g.sourceMapFilename\n    });\n    var transformedLines = str.split('\\n');\n    if (transformedLines.length > 1) {\n      state.g.bufferLine += transformedLines.length - 1;\n      state.g.bufferColumn = 0;\n    }\n    state.g.bufferColumn +=\n      transformedLines[transformedLines.length - 1].length;\n  }\n  state.g.buffer += str;\n}\n\n/**\n * Update indent using state.indentBy property. Indent is measured in\n * double spaces. Updates a single line only.\n *\n * @param {string} str\n * @param {object} state\n * @return {string}\n */\nfunction updateIndent(str, state) {\n  /*jshint -W004*/\n  var indentBy = state.indentBy;\n  if (indentBy < 0) {\n    for (var i = 0; i < -indentBy; i++) {\n      str = str.replace(leadingIndentRegexp, '$1');\n    }\n  } else {\n    for (var i = 0; i < indentBy; i++) {\n      str = str.replace(leadingIndentRegexp, '$1$2$2');\n    }\n  }\n  return str;\n}\n\n/**\n * Calculates indent from the beginning of the line until \"start\" or the first\n * character before start.\n * @example\n *   \"  foo.bar()\"\n *         ^\n *       start\n *   indent will be \"  \"\n *\n * @param  {number} start\n * @param  {object} state\n * @return {string}\n */\nfunction indentBefore(start, state) {\n  var end = start;\n  start = start - 1;\n\n  while (start > 0 && state.g.source[start] != '\\n') {\n    if (!state.g.source[start].match(/[ \\t]/)) {\n      end = start;\n    }\n    start--;\n  }\n  return state.g.source.substring(start + 1, end);\n}\n\nfunction getDocblock(state) {\n  if (!state.g.docblock) {\n    var docblock = require('./docblock');\n    state.g.docblock =\n      docblock.parseAsObject(docblock.extract(state.g.source));\n  }\n  return state.g.docblock;\n}\n\nfunction identWithinLexicalScope(identName, state, stopBeforeNode) {\n  var currScope = state.localScope;\n  while (currScope) {\n    if (currScope.identifiers[identName] !== undefined) {\n      return true;\n    }\n\n    if (stopBeforeNode && currScope.parentNode === stopBeforeNode) {\n      break;\n    }\n\n    currScope = currScope.parentScope;\n  }\n  return false;\n}\n\nfunction identInLocalScope(identName, state) {\n  return state.localScope.identifiers[identName] !== undefined;\n}\n\n/**\n * @param {object} boundaryNode\n * @param {?array} path\n * @return {?object} node\n */\nfunction initScopeMetadata(boundaryNode, path, node) {\n  return {\n    boundaryNode: boundaryNode,\n    bindingPath: path,\n    bindingNode: node\n  };\n}\n\nfunction declareIdentInLocalScope(identName, metaData, state) {\n  state.localScope.identifiers[identName] = {\n    boundaryNode: metaData.boundaryNode,\n    path: metaData.bindingPath,\n    node: metaData.bindingNode,\n    state: Object.create(state)\n  };\n}\n\nfunction getLexicalBindingMetadata(identName, state) {\n  var currScope = state.localScope;\n  while (currScope) {\n    if (currScope.identifiers[identName] !== undefined) {\n      return currScope.identifiers[identName];\n    }\n\n    currScope = currScope.parentScope;\n  }\n}\n\nfunction getLocalBindingMetadata(identName, state) {\n  return state.localScope.identifiers[identName];\n}\n\n/**\n * Apply the given analyzer function to the current node. If the analyzer\n * doesn't return false, traverse each child of the current node using the given\n * traverser function.\n *\n * @param {function} analyzer\n * @param {function} traverser\n * @param {object} node\n * @param {array} path\n * @param {object} state\n */\nfunction analyzeAndTraverse(analyzer, traverser, node, path, state) {\n  if (node.type) {\n    if (analyzer(node, path, state) === false) {\n      return;\n    }\n    path.unshift(node);\n  }\n\n  getOrderedChildren(node).forEach(function(child) {\n    traverser(child, path, state);\n  });\n\n  node.type && path.shift();\n}\n\n/**\n * It is crucial that we traverse in order, or else catchup() on a later\n * node that is processed out of order can move the buffer past a node\n * that we haven't handled yet, preventing us from modifying that node.\n *\n * This can happen when a node has multiple properties containing children.\n * For example, XJSElement nodes have `openingElement`, `closingElement` and\n * `children`. If we traverse `openingElement`, then `closingElement`, then\n * when we get to `children`, the buffer has already caught up to the end of\n * the closing element, after the children.\n *\n * This is basically a Schwartzian transform. Collects an array of children,\n * each one represented as [child, startIndex]; sorts the array by start\n * index; then traverses the children in that order.\n */\nfunction getOrderedChildren(node) {\n  var queue = [];\n  for (var key in node) {\n    if (node.hasOwnProperty(key)) {\n      enqueueNodeWithStartIndex(queue, node[key]);\n    }\n  }\n  queue.sort(function(a, b) { return a[1] - b[1]; });\n  return queue.map(function(pair) { return pair[0]; });\n}\n\n/**\n * Helper function for analyzeAndTraverse which queues up all of the children\n * of the given node.\n *\n * Children can also be found in arrays, so we basically want to merge all of\n * those arrays together so we can sort them and then traverse the children\n * in order.\n *\n * One example is the Program node. It contains `body` and `comments`, both\n * arrays. Lexographically, comments are interspersed throughout the body\n * nodes, but esprima's AST groups them together.\n */\nfunction enqueueNodeWithStartIndex(queue, node) {\n  if (typeof node !== 'object' || node === null) {\n    return;\n  }\n  if (node.range) {\n    queue.push([node, node.range[0]]);\n  } else if (Array.isArray(node)) {\n    for (var ii = 0; ii < node.length; ii++) {\n      enqueueNodeWithStartIndex(queue, node[ii]);\n    }\n  }\n}\n\n/**\n * Checks whether a node or any of its sub-nodes contains\n * a syntactic construct of the passed type.\n * @param {object} node - AST node to test.\n * @param {string} type - node type to lookup.\n */\nfunction containsChildOfType(node, type) {\n  return containsChildMatching(node, function(node) {\n    return node.type === type;\n  });\n}\n\nfunction containsChildMatching(node, matcher) {\n  var foundMatchingChild = false;\n  function nodeTypeAnalyzer(node) {\n    if (matcher(node) === true) {\n      foundMatchingChild = true;\n      return false;\n    }\n  }\n  function nodeTypeTraverser(child, path, state) {\n    if (!foundMatchingChild) {\n      foundMatchingChild = containsChildMatching(child, matcher);\n    }\n  }\n  analyzeAndTraverse(\n    nodeTypeAnalyzer,\n    nodeTypeTraverser,\n    node,\n    []\n  );\n  return foundMatchingChild;\n}\n\nvar scopeTypes = {};\nscopeTypes[Syntax.ArrowFunctionExpression] = true;\nscopeTypes[Syntax.FunctionExpression] = true;\nscopeTypes[Syntax.FunctionDeclaration] = true;\nscopeTypes[Syntax.Program] = true;\n\nfunction getBoundaryNode(path) {\n  for (var ii = 0; ii < path.length; ++ii) {\n    if (scopeTypes[path[ii].type]) {\n      return path[ii];\n    }\n  }\n  throw new Error(\n    'Expected to find a node with one of the following types in path:\\n' +\n    JSON.stringify(Object.keys(scopeTypes))\n  );\n}\n\nfunction getTempVar(tempVarIndex) {\n  return '$__' + tempVarIndex;\n}\n\nfunction injectTempVar(state) {\n  var tempVar = '$__' + (state.localScope.tempVarIndex++);\n  state.localScope.tempVars.push(tempVar);\n  return tempVar;\n}\n\nfunction injectTempVarDeclarations(state, index) {\n  if (state.localScope.tempVars.length) {\n    state.g.buffer =\n      state.g.buffer.slice(0, index) +\n      'var ' + state.localScope.tempVars.join(', ') + ';' +\n      state.g.buffer.slice(index);\n    state.localScope.tempVars = [];\n  }\n}\n\nexports.analyzeAndTraverse = analyzeAndTraverse;\nexports.append = append;\nexports.catchup = catchup;\nexports.catchupNewlines = catchupNewlines;\nexports.catchupWhiteOut = catchupWhiteOut;\nexports.catchupWhiteSpace = catchupWhiteSpace;\nexports.containsChildMatching = containsChildMatching;\nexports.containsChildOfType = containsChildOfType;\nexports.createState = createState;\nexports.declareIdentInLocalScope = declareIdentInLocalScope;\nexports.getBoundaryNode = getBoundaryNode;\nexports.getDocblock = getDocblock;\nexports.getLexicalBindingMetadata = getLexicalBindingMetadata;\nexports.getLocalBindingMetadata = getLocalBindingMetadata;\nexports.getNextSyntacticCharOffset = getNextSyntacticCharOffset;\nexports.getNodeSourceText = getNodeSourceText;\nexports.getOrderedChildren = getOrderedChildren;\nexports.getTempVar = getTempVar;\nexports.identInLocalScope = identInLocalScope;\nexports.identWithinLexicalScope = identWithinLexicalScope;\nexports.indentBefore = indentBefore;\nexports.initScopeMetadata = initScopeMetadata;\nexports.injectTempVar = injectTempVar;\nexports.injectTempVarDeclarations = injectTempVarDeclarations;\nexports.move = move;\nexports.scopeTypes = scopeTypes;\nexports.updateIndent = updateIndent;\nexports.updateState = updateState;\n"]}