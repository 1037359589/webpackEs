{"version":3,"sources":["es6-destructuring-visitors.js"],"names":[],"mappings":"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","file":"es6-destructuring-visitors-compiled.js","sourcesContent":["/**\n * Copyright 2014 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*global exports:true*/\n\n/**\n * Implements ES6 destructuring assignment and pattern matchng.\n *\n * function init({port, ip, coords: [x, y]}) {\n *   return (x && y) ? {id, port} : {ip};\n * };\n *\n * function init($__0) {\n *   var\n *    port = $__0.port,\n *    ip = $__0.ip,\n *    $__1 = $__0.coords,\n *    x = $__1[0],\n *    y = $__1[1];\n *   return (x && y) ? {id, port} : {ip};\n * }\n *\n * var x, {ip, port} = init({ip, port});\n *\n * var x, $__0 = init({ip, port}), ip = $__0.ip, port = $__0.port;\n *\n */\nvar Syntax = require('esprima-fb').Syntax;\nvar utils = require('../src/utils');\n\nvar reservedWordsHelper = require('./reserved-words-helper');\nvar restParamVisitors = require('./es6-rest-param-visitors');\nvar restPropertyHelpers = require('./es7-rest-property-helpers');\n\n// -------------------------------------------------------\n// 1. Structured variable declarations.\n//\n// var [a, b] = [b, a];\n// var {x, y} = {y, x};\n// -------------------------------------------------------\n\nfunction visitStructuredVariable(traverse, node, path, state) {\n  // Allocate new temp for the pattern.\n  utils.append(utils.getTempVar(state.localScope.tempVarIndex) + '=', state);\n  // Skip the pattern and assign the init to the temp.\n  utils.catchupWhiteSpace(node.init.range[0], state);\n  traverse(node.init, path, state);\n  utils.catchup(node.init.range[1], state);\n  // Render the destructured data.\n  utils.append(',' + getDestructuredComponents(node.id, state), state);\n  state.localScope.tempVarIndex++;\n  return false;\n}\n\nvisitStructuredVariable.test = function(node, path, state) {\n  return node.type === Syntax.VariableDeclarator &&\n    isStructuredPattern(node.id);\n};\n\nfunction isStructuredPattern(node) {\n  return node.type === Syntax.ObjectPattern ||\n    node.type === Syntax.ArrayPattern;\n}\n\n// Main function which does actual recursive destructuring\n// of nested complex structures.\nfunction getDestructuredComponents(node, state) {\n  var tmpIndex = state.localScope.tempVarIndex;\n  var components = [];\n  var patternItems = getPatternItems(node);\n\n  for (var idx = 0; idx < patternItems.length; idx++) {\n    var item = patternItems[idx];\n    if (!item) {\n      continue;\n    }\n\n    if (item.type === Syntax.SpreadElement) {\n      // Spread/rest of an array.\n      // TODO(dmitrys): support spread in the middle of a pattern\n      // and also for function param patterns: [x, ...xs, y]\n      components.push(item.argument.name +\n        '=Array.prototype.slice.call(' +\n        utils.getTempVar(tmpIndex) + ',' + idx + ')'\n      );\n      continue;\n    }\n\n    if (item.type === Syntax.SpreadProperty) {\n      var restExpression = restPropertyHelpers.renderRestExpression(\n        utils.getTempVar(tmpIndex),\n        patternItems\n      );\n      components.push(item.argument.name + '=' + restExpression);\n      continue;\n    }\n\n    // Depending on pattern type (Array or Object), we get\n    // corresponding pattern item parts.\n    var accessor = getPatternItemAccessor(node, item, tmpIndex, idx);\n    var value = getPatternItemValue(node, item);\n\n    // TODO(dmitrys): implement default values: {x, y=5}\n    if (value.type === Syntax.Identifier) {\n      // Simple pattern item.\n      components.push(value.name + '=' + accessor);\n    } else {\n      // Complex sub-structure.\n      components.push(\n        utils.getTempVar(++state.localScope.tempVarIndex) + '=' + accessor +\n        ',' + getDestructuredComponents(value, state)\n      );\n    }\n  }\n\n  return components.join(',');\n}\n\nfunction getPatternItems(node) {\n  return node.properties || node.elements;\n}\n\nfunction getPatternItemAccessor(node, patternItem, tmpIndex, idx) {\n  var tmpName = utils.getTempVar(tmpIndex);\n  if (node.type === Syntax.ObjectPattern) {\n    if (reservedWordsHelper.isReservedWord(patternItem.key.name)) {\n      return tmpName + '[\"' + patternItem.key.name + '\"]';\n    } else if (patternItem.key.type === Syntax.Literal) {\n      return tmpName + '[' + JSON.stringify(patternItem.key.value) + ']';\n    } else if (patternItem.key.type === Syntax.Identifier) {\n      return tmpName + '.' + patternItem.key.name;\n    }\n  } else if (node.type === Syntax.ArrayPattern) {\n    return tmpName + '[' + idx + ']';\n  }\n}\n\nfunction getPatternItemValue(node, patternItem) {\n  return node.type === Syntax.ObjectPattern\n    ? patternItem.value\n    : patternItem;\n}\n\n// -------------------------------------------------------\n// 2. Assignment expression.\n//\n// [a, b] = [b, a];\n// ({x, y} = {y, x});\n// -------------------------------------------------------\n\nfunction visitStructuredAssignment(traverse, node, path, state) {\n  var exprNode = node.expression;\n  utils.append('var ' + utils.getTempVar(state.localScope.tempVarIndex) + '=', state);\n\n  utils.catchupWhiteSpace(exprNode.right.range[0], state);\n  traverse(exprNode.right, path, state);\n  utils.catchup(exprNode.right.range[1], state);\n\n  utils.append(\n    ';' + getDestructuredComponents(exprNode.left, state) + ';',\n    state\n  );\n\n  utils.catchupWhiteSpace(node.range[1], state);\n  state.localScope.tempVarIndex++;\n  return false;\n}\n\nvisitStructuredAssignment.test = function(node, path, state) {\n  // We consider the expression statement rather than just assignment\n  // expression to cover case with object patters which should be\n  // wrapped in grouping operator: ({x, y} = {y, x});\n  return node.type === Syntax.ExpressionStatement &&\n    node.expression.type === Syntax.AssignmentExpression &&\n    isStructuredPattern(node.expression.left);\n};\n\n// -------------------------------------------------------\n// 3. Structured parameter.\n//\n// function foo({x, y}) { ... }\n// -------------------------------------------------------\n\nfunction visitStructuredParameter(traverse, node, path, state) {\n  utils.append(utils.getTempVar(getParamIndex(node, path)), state);\n  utils.catchupWhiteSpace(node.range[1], state);\n  return true;\n}\n\nfunction getParamIndex(paramNode, path) {\n  var funcNode = path[0];\n  var tmpIndex = 0;\n  for (var k = 0; k < funcNode.params.length; k++) {\n    var param = funcNode.params[k];\n    if (param === paramNode) {\n      break;\n    }\n    if (isStructuredPattern(param)) {\n      tmpIndex++;\n    }\n  }\n  return tmpIndex;\n}\n\nvisitStructuredParameter.test = function(node, path, state) {\n  return isStructuredPattern(node) && isFunctionNode(path[0]);\n};\n\nfunction isFunctionNode(node) {\n  return (node.type == Syntax.FunctionDeclaration ||\n    node.type == Syntax.FunctionExpression ||\n    node.type == Syntax.MethodDefinition ||\n    node.type == Syntax.ArrowFunctionExpression);\n}\n\n// -------------------------------------------------------\n// 4. Function body for structured parameters.\n//\n// function foo({x, y}) { x; y; }\n// -------------------------------------------------------\n\nfunction visitFunctionBodyForStructuredParameter(traverse, node, path, state) {\n  var funcNode = path[0];\n\n  utils.catchup(funcNode.body.range[0] + 1, state);\n  renderDestructuredComponents(funcNode, state);\n\n  if (funcNode.rest) {\n    utils.append(\n      restParamVisitors.renderRestParamSetup(funcNode, state),\n      state\n    );\n  }\n\n  return true;\n}\n\nfunction renderDestructuredComponents(funcNode, state) {\n  var destructuredComponents = [];\n\n  for (var k = 0; k < funcNode.params.length; k++) {\n    var param = funcNode.params[k];\n    if (isStructuredPattern(param)) {\n      destructuredComponents.push(\n        getDestructuredComponents(param, state)\n      );\n      state.localScope.tempVarIndex++;\n    }\n  }\n\n  if (destructuredComponents.length) {\n    utils.append('var ' + destructuredComponents.join(',') + ';', state);\n  }\n}\n\nvisitFunctionBodyForStructuredParameter.test = function(node, path, state) {\n  return node.type === Syntax.BlockStatement && isFunctionNode(path[0]);\n};\n\nexports.visitorList = [\n  visitStructuredVariable,\n  visitStructuredAssignment,\n  visitStructuredParameter,\n  visitFunctionBodyForStructuredParameter\n];\n\nexports.renderDestructuredComponents = renderDestructuredComponents;\n\n"]}